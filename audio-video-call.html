<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebSocket Audio/Video Call</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
      color: white;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1600px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      margin-bottom: 10px;
      font-size: 2em;
    }

    .subtitle {
      text-align: center;
      color: #ecf0f1;
      opacity: 0.9;
      margin-bottom: 20px;
    }

    .status {
      text-align: center;
      padding: 15px;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      margin-bottom: 20px;
    }

    .status.connected {
      background: rgba(46, 204, 113, 0.3);
      border: 1px solid #2ecc71;
    }

    .controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }

    button {
      padding: 12px 30px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      background: #2ecc71;
      color: white;
      cursor: pointer;
      transition: all 0.3s;
    }

    button:hover:not(:disabled) {
      background: #27ae60;
      transform: translateY(-2px);
    }

    button:disabled {
      background: #7f8c8d;
      cursor: not-allowed;
      opacity: 0.6;
    }

    button.muted {
      background: #e74c3c;
    }

    .videos {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .video-container {
      background: rgba(0,0,0,0.4);
      border-radius: 10px;
      padding: 10px;
      position: relative;
    }

    .video-label {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0,0,0,0.8);
      padding: 8px 15px;
      border-radius: 5px;
      z-index: 10;
      font-size: 14px;
    }

    .audio-indicator {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(46, 204, 113, 0.8);
      padding: 8px;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .audio-indicator.muted {
      background: rgba(231, 76, 60, 0.8);
    }

    video, canvas {
      width: 100%;
      height: auto;
      min-height: 300px;
      border-radius: 5px;
      background: #000;
      display: block;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      padding: 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
    }

    .stat {
      text-align: center;
    }

    .stat-value {
      font-size: 28px;
      font-weight: bold;
      color: #2ecc71;
    }

    .stat-label {
      font-size: 12px;
      color: #bdc3c7;
      margin-top: 5px;
    }

    .quality-control {
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(0,0,0,0.3);
      padding: 10px 15px;
      border-radius: 5px;
    }

    input[type="range"] {
      width: 100px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ðŸŽ¥ WebSocket Audio/Video Streaming</h1>
    <p class="subtitle">Full audio and video support through VPS relay</p>
    
    <div class="status" id="status">
      Disconnected - Click "Start Call" to begin
    </div>
    
    <div class="controls">
      <button id="startBtn" onclick="startCall()">Start Call</button>
      <button id="stopBtn" onclick="stopCall()" disabled>End Call</button>
      <button id="muteBtn" onclick="toggleMute()" disabled>Mute Audio</button>
      
      <div class="quality-control">
        <label>Video Quality:</label>
        <input type="range" id="quality" min="0.3" max="0.9" step="0.1" value="0.6">
        <span id="qualityValue">0.6</span>
      </div>
      
      <div class="quality-control">
        <label>FPS:</label>
        <input type="range" id="fps" min="5" max="30" step="5" value="15">
        <span id="fpsValue">15</span>
      </div>
    </div>
    
    <div class="videos" id="videosContainer">
      <!-- Videos will be added dynamically -->
    </div>
    
    <div class="stats">
      <div class="stat">
        <div class="stat-value" id="participants">0</div>
        <div class="stat-label">Participants</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="framesSent">0</div>
        <div class="stat-label">Frames Sent</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="framesReceived">0</div>
        <div class="stat-label">Frames Received</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="audioPackets">0</div>
        <div class="stat-label">Audio Packets</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="bandwidth">0</div>
        <div class="stat-label">KB/s</div>
      </div>
    </div>
  </div>

  <script>
    const WS_URL = 'ws://194.87.103.57:3000/ws';
    
    let ws = null;
    let localStream = null;
    let audioContext = null;
    let audioProcessor = null;
    let audioSource = null;
    let isStreaming = false;
    let isMuted = false;
    let myId = null;
    let captureInterval = null;
    let audioInterval = null;
    let participants = new Map();
    
    // Stats
    let framesSent = 0;
    let framesReceived = 0;
    let audioPacketsSent = 0;
    let audioPacketsReceived = 0;
    let bytesSent = 0;
    let lastBandwidthTime = Date.now();
    
    // Quality settings
    document.getElementById('quality').addEventListener('input', (e) => {
      document.getElementById('qualityValue').textContent = e.target.value;
    });
    
    document.getElementById('fps').addEventListener('input', (e) => {
      document.getElementById('fpsValue').textContent = e.target.value;
      if (isStreaming) {
        restartCapture();
      }
    });
    
    async function startCall() {
      try {
        // Get user media with audio
        localStream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: 640 },
            height: { ideal: 480 },
            frameRate: { ideal: 30 }
          },
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        });
        
        // Add local video
        addVideoElement('local', 'You', true);
        const localVideo = document.getElementById('video-local');
        if (localVideo) {
          localVideo.srcObject = localStream;
          console.log('Local video stream attached');
        }
        
        // Setup audio processing
        setupAudioProcessing();
        
        // Connect to WebSocket
        connectWebSocket();
        
        // Update UI
        document.getElementById('startBtn').disabled = true;
        document.getElementById('stopBtn').disabled = false;
        document.getElementById('muteBtn').disabled = false;
        
        isStreaming = true;
        
      } catch (error) {
        console.error('Error starting call:', error);
        updateStatus('Error: ' + error.message, 'error');
      }
    }
    
    function setupAudioProcessing() {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      audioSource = audioContext.createMediaStreamSource(localStream);
      
      // Create a script processor for capturing audio
      audioProcessor = audioContext.createScriptProcessor(2048, 1, 1);
      
      audioProcessor.onaudioprocess = (e) => {
        if (!isMuted && ws && ws.readyState === WebSocket.OPEN) {
          const inputData = e.inputBuffer.getChannelData(0);
          
          // Convert Float32Array to base64
          const buffer = new ArrayBuffer(inputData.length * 2);
          const view = new Int16Array(buffer);
          
          for (let i = 0; i < inputData.length; i++) {
            const s = Math.max(-1, Math.min(1, inputData[i]));
            view[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
          }
          
          // Convert to base64
          const bytes = new Uint8Array(buffer);
          let binary = '';
          for (let i = 0; i < bytes.byteLength; i++) {
            binary += String.fromCharCode(bytes[i]);
          }
          const base64Audio = window.btoa(binary);
          
          // Send audio frame
          ws.send(JSON.stringify({
            type: 'audio-frame',
            data: base64Audio,
            timestamp: Date.now(),
            sampleRate: audioContext.sampleRate
          }));
          
          audioPacketsSent++;
          bytesSent += base64Audio.length;
        }
      };
      
      // Connect the audio graph
      audioSource.connect(audioProcessor);
      audioProcessor.connect(audioContext.destination);
    }
    
    function connectWebSocket() {
      updateStatus('Connecting to server...', 'connecting');
      
      ws = new WebSocket(WS_URL);
      ws.binaryType = 'arraybuffer';
      
      ws.onopen = () => {
        console.log('Connected to WebSocket server');
        myId = 'user-' + Math.random().toString(36).substr(2, 9);
        
        // Join room
        ws.send(JSON.stringify({
          type: 'join',
          id: myId,
          room: 'global'
        }));
        
        updateStatus('Connected - Audio/Video Streaming Active', 'connected');
      };
      
      ws.onmessage = (event) => {
        if (typeof event.data === 'string') {
          const message = JSON.parse(event.data);
          handleMessage(message);
        } else {
          handleBinaryFrame(event.data);
        }
      };
      
      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        updateStatus('Connection error', 'error');
      };
      
      ws.onclose = () => {
        console.log('Disconnected from server');
        updateStatus('Disconnected', 'disconnected');
        stopCall();
      };
    }
    
    function handleMessage(message) {
      switch (message.type) {
        case 'welcome':
          console.log('Joined as:', message.id);
          myId = message.id;
          
          // Add existing participants
          if (message.participants && message.participants.length > 0) {
            console.log('Existing participants:', message.participants);
            message.participants.forEach(id => {
              addParticipant(id);
            });
          }
          updateParticipantCount();
          
          // Start sending frames
          setTimeout(() => {
            console.log('Starting frame capture');
            startFrameCapture();
          }, 1000);
          break;
          
        case 'participant-joined':
          console.log('New participant joined:', message.id);
          if (message.id !== myId) {
            addParticipant(message.id);
            updateParticipantCount();
          }
          break;
          
        case 'participant-left':
          console.log('Participant left:', message.id);
          removeParticipant(message.id);
          updateParticipantCount();
          break;
          
        case 'video-frame':
          displayFrame(message.from, message.data);
          framesReceived++;
          document.getElementById('framesReceived').textContent = framesReceived;
          break;
          
        case 'audio-frame':
          if (message.from !== myId) {
            playAudioFrame(message.from, message.data, message.sampleRate);
            audioPacketsReceived++;
            document.getElementById('audioPackets').textContent = audioPacketsReceived + audioPacketsSent;
          }
          break;
          
        case 'incoming-frame':
          participants.set('pending-frame', message);
          break;
      }
    }
    
    function handleBinaryFrame(arrayBuffer) {
      const metadata = participants.get('pending-frame');
      if (!metadata) return;
      
      participants.delete('pending-frame');
      
      // Convert ArrayBuffer to base64
      const bytes = new Uint8Array(arrayBuffer);
      let binary = '';
      for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      const base64 = window.btoa(binary);
      
      // Check frame type
      if (metadata.frameType === 'audio') {
        playAudioFrame(metadata.from, base64, metadata.sampleRate);
        audioPacketsReceived++;
        document.getElementById('audioPackets').textContent = audioPacketsReceived + audioPacketsSent;
      } else {
        displayFrame(metadata.from, 'data:image/jpeg;base64,' + base64);
        framesReceived++;
        document.getElementById('framesReceived').textContent = framesReceived;
      }
    }
    
    function playAudioFrame(participantId, base64Audio, sampleRate) {
      if (!participants.has(participantId)) {
        addParticipant(participantId);
      }
      
      const participant = participants.get(participantId);
      if (!participant.audioContext) {
        participant.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        participant.audioQueue = [];
        participant.isPlaying = false;
      }
      
      // Decode base64 to audio data
      const binary = window.atob(base64Audio);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      
      const int16Array = new Int16Array(bytes.buffer);
      const float32Array = new Float32Array(int16Array.length);
      
      for (let i = 0; i < int16Array.length; i++) {
        float32Array[i] = int16Array[i] / (int16Array[i] < 0 ? 0x8000 : 0x7FFF);
      }
      
      // Create audio buffer
      const audioBuffer = participant.audioContext.createBuffer(1, float32Array.length, sampleRate || 48000);
      audioBuffer.copyToChannel(float32Array, 0);
      
      // Queue and play
      participant.audioQueue.push(audioBuffer);
      if (!participant.isPlaying) {
        playNextAudioBuffer(participant);
      }
    }
    
    function playNextAudioBuffer(participant) {
      if (participant.audioQueue.length === 0) {
        participant.isPlaying = false;
        return;
      }
      
      participant.isPlaying = true;
      const buffer = participant.audioQueue.shift();
      
      const source = participant.audioContext.createBufferSource();
      source.buffer = buffer;
      source.connect(participant.audioContext.destination);
      source.onended = () => {
        playNextAudioBuffer(participant);
      };
      source.start();
    }
    
    function startFrameCapture() {
      if (captureInterval) return;
      
      const fps = parseInt(document.getElementById('fps').value);
      const interval = 1000 / fps;
      
      const video = document.getElementById('video-local');
      if (!video) return;
      
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = 640;
      canvas.height = 480;
      
      console.log('Starting capture at', fps, 'FPS');
      
      captureInterval = setInterval(() => {
        if (!video || !ws || ws.readyState !== WebSocket.OPEN) return;
        
        if (video.readyState === video.HAVE_ENOUGH_DATA) {
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          
          const quality = parseFloat(document.getElementById('quality').value);
          
          canvas.toBlob((blob) => {
            if (blob) {
              const reader = new FileReader();
              reader.onload = () => {
                const base64 = reader.result;
                ws.send(JSON.stringify({
                  type: 'video-frame',
                  data: base64,
                  timestamp: Date.now()
                }));
                
                framesSent++;
                bytesSent += base64.length;
                document.getElementById('framesSent').textContent = framesSent;
              };
              reader.readAsDataURL(blob);
            }
          }, 'image/jpeg', quality);
        }
      }, interval);
    }
    
    function restartCapture() {
      if (captureInterval) {
        clearInterval(captureInterval);
        captureInterval = null;
        startFrameCapture();
      }
    }
    
    function toggleMute() {
      isMuted = !isMuted;
      const btn = document.getElementById('muteBtn');
      btn.textContent = isMuted ? 'Unmute Audio' : 'Mute Audio';
      btn.className = isMuted ? 'muted' : '';
      
      // Update local audio indicator
      const indicator = document.querySelector('#video-container-local .audio-indicator');
      if (indicator) {
        indicator.className = 'audio-indicator' + (isMuted ? ' muted' : '');
      }
      
      // Mute/unmute audio track
      if (localStream) {
        const audioTracks = localStream.getAudioTracks();
        audioTracks.forEach(track => {
          track.enabled = !isMuted;
        });
      }
    }
    
    function addParticipant(id) {
      if (!participants.has(id)) {
        participants.set(id, {});
        addVideoElement(id, `User ${id.substr(0, 6)}`, false);
      }
    }
    
    function removeParticipant(id) {
      const participant = participants.get(id);
      if (participant && participant.audioContext) {
        participant.audioContext.close();
      }
      participants.delete(id);
      removeVideoElement(id);
    }
    
    function addVideoElement(id, label, isLocal) {
      if (document.getElementById(`video-container-${id}`)) return;
      
      const container = document.createElement('div');
      container.className = 'video-container';
      container.id = `video-container-${id}`;
      
      const labelDiv = document.createElement('div');
      labelDiv.className = 'video-label';
      labelDiv.textContent = label;
      
      const audioIndicator = document.createElement('div');
      audioIndicator.className = 'audio-indicator';
      audioIndicator.innerHTML = 'ðŸŽ¤';
      
      if (id === 'local') {
        const video = document.createElement('video');
        video.id = `video-${id}`;
        video.autoplay = true;
        video.muted = true;
        video.playsinline = true;
        container.appendChild(labelDiv);
        container.appendChild(audioIndicator);
        container.appendChild(video);
      } else {
        const canvas = document.createElement('canvas');
        canvas.id = `canvas-${id}`;
        canvas.width = 640;
        canvas.height = 480;
        container.appendChild(labelDiv);
        container.appendChild(audioIndicator);
        container.appendChild(canvas);
      }
      
      document.getElementById('videosContainer').appendChild(container);
    }
    
    function removeVideoElement(id) {
      const element = document.getElementById(`video-container-${id}`);
      if (element) {
        element.remove();
      }
    }
    
    function displayFrame(participantId, imageData) {
      const canvas = document.getElementById(`canvas-${participantId}`);
      if (!canvas) {
        addParticipant(participantId);
        return;
      }
      
      const ctx = canvas.getContext('2d');
      const img = new Image();
      img.onload = () => {
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      };
      img.src = imageData;
    }
    
    function stopCall() {
      isStreaming = false;
      
      // Stop capture
      if (captureInterval) {
        clearInterval(captureInterval);
        captureInterval = null;
      }
      
      // Stop audio processing
      if (audioProcessor) {
        audioProcessor.disconnect();
        audioProcessor = null;
      }
      if (audioSource) {
        audioSource.disconnect();
        audioSource = null;
      }
      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }
      
      // Stop local stream
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      
      // Close WebSocket
      if (ws) {
        ws.close();
        ws = null;
      }
      
      // Clear videos
      document.getElementById('videosContainer').innerHTML = '';
      
      // Clean up participants
      participants.forEach(participant => {
        if (participant.audioContext) {
          participant.audioContext.close();
        }
      });
      participants.clear();
      
      // Reset UI
      document.getElementById('startBtn').disabled = false;
      document.getElementById('stopBtn').disabled = true;
      document.getElementById('muteBtn').disabled = true;
      
      updateStatus('Call ended', 'disconnected');
    }
    
    function updateStatus(message, type) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = 'status ' + (type === 'connected' ? 'connected' : '');
    }
    
    function updateParticipantCount() {
      const count = participants.size;
      document.getElementById('participants').textContent = count;
    }
    
    // Monitor bandwidth
    setInterval(() => {
      const now = Date.now();
      const elapsed = (now - lastBandwidthTime) / 1000;
      const bandwidth = Math.round((bytesSent / 1024) / elapsed);
      document.getElementById('bandwidth').textContent = bandwidth;
      
      bytesSent = 0;
      lastBandwidthTime = now;
    }, 1000);
  </script>
</body>
</html>