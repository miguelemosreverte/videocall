<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebSocket Video Call (Direct Relay)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
      color: white;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1600px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      margin-bottom: 10px;
      font-size: 2em;
    }

    .subtitle {
      text-align: center;
      color: #ecf0f1;
      opacity: 0.9;
      margin-bottom: 20px;
    }

    .status {
      text-align: center;
      padding: 15px;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      margin-bottom: 20px;
    }

    .status.connected {
      background: rgba(46, 204, 113, 0.3);
      border: 1px solid #2ecc71;
    }

    .controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }

    button {
      padding: 12px 30px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      background: #2ecc71;
      color: white;
      cursor: pointer;
      transition: all 0.3s;
    }

    button:hover:not(:disabled) {
      background: #27ae60;
      transform: translateY(-2px);
    }

    button:disabled {
      background: #7f8c8d;
      cursor: not-allowed;
      opacity: 0.6;
    }

    .videos {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .video-container {
      background: rgba(0,0,0,0.4);
      border-radius: 10px;
      padding: 10px;
      position: relative;
    }

    .video-label {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0,0,0,0.8);
      padding: 8px 15px;
      border-radius: 5px;
      z-index: 10;
      font-size: 14px;
    }

    video, canvas {
      width: 100%;
      height: auto;
      min-height: 300px;
      border-radius: 5px;
      background: #000;
      display: block;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      padding: 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
    }

    .stat {
      text-align: center;
    }

    .stat-value {
      font-size: 28px;
      font-weight: bold;
      color: #2ecc71;
    }

    .stat-label {
      font-size: 12px;
      color: #bdc3c7;
      margin-top: 5px;
    }

    .quality-control {
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(0,0,0,0.3);
      padding: 10px 15px;
      border-radius: 5px;
    }

    input[type="range"] {
      width: 100px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ðŸŽ¥ WebSocket Video Streaming</h1>
    <p class="subtitle">Direct video relay through VPS (no WebRTC)</p>
    
    <div class="status" id="status">
      Disconnected - Click "Start Streaming" to begin
    </div>
    
    <div class="controls">
      <button id="startBtn" onclick="startStreaming()">Start Streaming</button>
      <button id="stopBtn" onclick="stopStreaming()" disabled>Stop Streaming</button>
      
      <div class="quality-control">
        <label>Quality:</label>
        <input type="range" id="quality" min="0.3" max="0.9" step="0.1" value="0.6">
        <span id="qualityValue">0.6</span>
      </div>
      
      <div class="quality-control">
        <label>FPS:</label>
        <input type="range" id="fps" min="5" max="30" step="5" value="15">
        <span id="fpsValue">15</span>
      </div>
    </div>
    
    <div class="videos" id="videosContainer">
      <!-- Videos will be added dynamically -->
    </div>
    
    <div class="stats">
      <div class="stat">
        <div class="stat-value" id="participants">0</div>
        <div class="stat-label">Participants</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="framesSent">0</div>
        <div class="stat-label">Frames Sent</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="framesReceived">0</div>
        <div class="stat-label">Frames Received</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="bandwidth">0</div>
        <div class="stat-label">KB/s</div>
      </div>
    </div>
  </div>

  <script>
    const WS_URL = 'ws://194.87.103.57:3000/';  // Direct connection to port 3000
    
    let ws = null;
    let localStream = null;
    let isStreaming = false;
    let myId = null;
    let captureInterval = null;
    let participants = new Map();
    
    // Stats
    let framesSent = 0;
    let framesReceived = 0;
    let bytesSent = 0;
    let lastBandwidthTime = Date.now();
    
    // Quality settings
    document.getElementById('quality').addEventListener('input', (e) => {
      document.getElementById('qualityValue').textContent = e.target.value;
    });
    
    document.getElementById('fps').addEventListener('input', (e) => {
      document.getElementById('fpsValue').textContent = e.target.value;
      if (isStreaming) {
        restartCapture();
      }
    });
    
    async function startStreaming() {
      try {
        // Get user media
        localStream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: 640 },
            height: { ideal: 480 },
            frameRate: { ideal: 30 }
          },
          audio: false // No audio for now to reduce bandwidth
        });
        
        // Add local video
        addVideoElement('local', 'You');
        const localVideo = document.getElementById('video-local');
        if (localVideo) {
          localVideo.srcObject = localStream;
          console.log('Local video stream attached');
        } else {
          console.error('Local video element not found!');
        }
        
        // Connect to WebSocket
        connectWebSocket();
        
        // Update UI
        document.getElementById('startBtn').disabled = true;
        document.getElementById('stopBtn').disabled = false;
        
        isStreaming = true;
        
      } catch (error) {
        console.error('Error starting stream:', error);
        updateStatus('Error: ' + error.message, 'error');
      }
    }
    
    function connectWebSocket() {
      updateStatus('Connecting to server...', 'connecting');
      
      ws = new WebSocket(WS_URL);
      ws.binaryType = 'arraybuffer';
      
      ws.onopen = () => {
        console.log('Connected to WebSocket server');
        myId = 'user-' + Math.random().toString(36).substr(2, 9);
        
        // Join room
        ws.send(JSON.stringify({
          type: 'join',
          id: myId,
          room: 'global'
        }));
        
        updateStatus('Connected - Streaming to VPS', 'connected');
      };
      
      ws.onmessage = (event) => {
        if (typeof event.data === 'string') {
          // JSON message
          const message = JSON.parse(event.data);
          handleMessage(message);
        } else {
          // Binary frame data - should be preceded by metadata
          handleBinaryFrame(event.data);
        }
      };
      
      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        updateStatus('Connection error', 'error');
      };
      
      ws.onclose = () => {
        console.log('Disconnected from server');
        updateStatus('Disconnected', 'disconnected');
        stopStreaming();
      };
    }
    
    function handleMessage(message) {
      switch (message.type) {
        case 'welcome':
          console.log('Joined as:', message.id);
          myId = message.id;
          
          // Add existing participants
          if (message.participants && message.participants.length > 0) {
            console.log('Existing participants:', message.participants);
            message.participants.forEach(id => {
              addParticipant(id);
            });
          }
          updateParticipantCount();
          
          // Start sending frames after a delay to ensure video is ready
          setTimeout(() => {
            console.log('Starting frame capture');
            startFrameCapture();
          }, 1000);
          break;
          
        case 'participant-joined':
          console.log('New participant joined:', message.id);
          if (message.id !== myId) {
            addParticipant(message.id);
            updateParticipantCount();
          }
          break;
          
        case 'participant-left':
          console.log('Participant left:', message.id);
          removeParticipant(message.id);
          updateParticipantCount();
          break;
          
        case 'video-frame':
          // Received frame from another participant
          displayFrame(message.from, message.data);
          framesReceived++;
          document.getElementById('framesReceived').textContent = framesReceived;
          break;
          
        case 'incoming-frame':
          // Metadata for incoming binary frame
          // Next message will be the binary data
          // Store metadata for processing
          participants.set('pending-frame', message);
          break;
      }
    }
    
    function handleBinaryFrame(arrayBuffer) {
      // Get metadata from pending
      const metadata = participants.get('pending-frame');
      if (!metadata) return;
      
      participants.delete('pending-frame');
      
      // Convert ArrayBuffer to base64
      const bytes = new Uint8Array(arrayBuffer);
      let binary = '';
      for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      const base64 = window.btoa(binary);
      
      // Display the frame
      displayFrame(metadata.from, 'data:image/jpeg;base64,' + base64);
      framesReceived++;
      document.getElementById('framesReceived').textContent = framesReceived;
    }
    
    function startFrameCapture() {
      if (captureInterval) {
        console.log('Capture already running');
        return;
      }
      
      const fps = parseInt(document.getElementById('fps').value);
      const interval = 1000 / fps;
      
      const video = document.getElementById('video-local');
      if (!video) {
        console.error('Local video element not found');
        return;
      }
      
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = 640;
      canvas.height = 480;
      
      console.log('Starting capture at', fps, 'FPS');
      
      let frameCount = 0;
      captureInterval = setInterval(() => {
        if (!video || !ws || ws.readyState !== WebSocket.OPEN) {
          return;
        }
        
        if (video.readyState === video.HAVE_ENOUGH_DATA) {
          // Draw video frame to canvas
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          
          // Get quality setting
          const quality = parseFloat(document.getElementById('quality').value);
          
          // Convert to JPEG
          canvas.toBlob((blob) => {
            if (blob) {
              // Send as base64 for simplicity
              const reader = new FileReader();
              reader.onload = () => {
                const base64 = reader.result;
                ws.send(JSON.stringify({
                  type: 'video-frame',
                  data: base64,
                  timestamp: Date.now()
                }));
                
                framesSent++;
                bytesSent += base64.length;
                document.getElementById('framesSent').textContent = framesSent;
                
                // Log first few frames for debugging
                if (++frameCount <= 3) {
                  console.log('Sent frame', frameCount, 'size:', base64.length);
                }
              };
              reader.readAsDataURL(blob);
            }
          }, 'image/jpeg', quality);
        } else {
          console.log('Video not ready, state:', video.readyState);
        }
      }, interval);
    }
    
    function restartCapture() {
      if (captureInterval) {
        clearInterval(captureInterval);
        startFrameCapture();
      }
    }
    
    function addParticipant(id) {
      if (!participants.has(id)) {
        participants.set(id, {});
        addVideoElement(id, `User ${id.substr(0, 6)}`);
      }
    }
    
    function removeParticipant(id) {
      participants.delete(id);
      removeVideoElement(id);
    }
    
    function addVideoElement(id, label) {
      if (document.getElementById(`video-container-${id}`)) return;
      
      const container = document.createElement('div');
      container.className = 'video-container';
      container.id = `video-container-${id}`;
      
      const labelDiv = document.createElement('div');
      labelDiv.className = 'video-label';
      labelDiv.textContent = label;
      
      if (id === 'local') {
        const video = document.createElement('video');
        video.id = `video-${id}`;
        video.autoplay = true;
        video.muted = true;
        video.playsinline = true;
        container.appendChild(labelDiv);
        container.appendChild(video);
      } else {
        const canvas = document.createElement('canvas');
        canvas.id = `canvas-${id}`;
        canvas.width = 640;
        canvas.height = 480;
        container.appendChild(labelDiv);
        container.appendChild(canvas);
      }
      
      document.getElementById('videosContainer').appendChild(container);
    }
    
    function removeVideoElement(id) {
      const element = document.getElementById(`video-container-${id}`);
      if (element) {
        element.remove();
      }
    }
    
    function displayFrame(participantId, imageData) {
      const canvas = document.getElementById(`canvas-${participantId}`);
      if (!canvas) {
        addParticipant(participantId);
        return;
      }
      
      const ctx = canvas.getContext('2d');
      const img = new Image();
      img.onload = () => {
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      };
      img.src = imageData;
    }
    
    function stopStreaming() {
      isStreaming = false;
      
      // Stop capture
      if (captureInterval) {
        clearInterval(captureInterval);
        captureInterval = null;
      }
      
      // Stop local stream
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      
      // Close WebSocket
      if (ws) {
        ws.close();
        ws = null;
      }
      
      // Clear videos
      document.getElementById('videosContainer').innerHTML = '';
      participants.clear();
      
      // Reset UI
      document.getElementById('startBtn').disabled = false;
      document.getElementById('stopBtn').disabled = true;
      
      updateStatus('Stopped', 'disconnected');
    }
    
    function updateStatus(message, type) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = 'status ' + (type === 'connected' ? 'connected' : '');
    }
    
    function updateParticipantCount() {
      const count = participants.size;
      document.getElementById('participants').textContent = count;
      console.log('Participant count:', count);
    }
    
    // Monitor bandwidth
    setInterval(() => {
      const now = Date.now();
      const elapsed = (now - lastBandwidthTime) / 1000;
      const bandwidth = Math.round((bytesSent / 1024) / elapsed);
      document.getElementById('bandwidth').textContent = bandwidth;
      
      bytesSent = 0;
      lastBandwidthTime = now;
    }, 1000);
  </script>
</body>
</html>