<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VPS Video Call - WebGPU Motion Vectors</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      width: 100%;
    }

    h1 {
      text-align: center;
      margin-bottom: 10px;
      font-size: 2.5em;
    }

    .subtitle {
      text-align: center;
      opacity: 0.9;
      margin-bottom: 30px;
    }

    .video-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    .video-wrapper {
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      padding: 10px;
      position: relative;
    }

    .video-label {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0,0,0,0.7);
      padding: 5px 15px;
      border-radius: 5px;
      font-size: 14px;
      z-index: 10;
    }

    video, canvas {
      width: 100%;
      height: auto;
      border-radius: 5px;
      background: #000;
    }

    .controls {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
      align-items: center;
    }

    button {
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background: #4CAF50;
      color: white;
      transition: all 0.3s;
    }

    button:hover {
      background: #45a049;
      transform: translateY(-2px);
    }

    button:disabled {
      background: #666;
      cursor: not-allowed;
    }

    .resolution-control {
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(0,0,0,0.3);
      padding: 10px 15px;
      border-radius: 5px;
    }

    input[type="range"] {
      width: 150px;
    }

    .stats {
      background: rgba(0,0,0,0.5);
      padding: 15px;
      border-radius: 10px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.6;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      margin: 5px 0;
    }

    .status {
      text-align: center;
      padding: 10px;
      background: rgba(0,0,0,0.3);
      border-radius: 5px;
      margin-bottom: 20px;
    }

    .status.connected {
      background: rgba(76, 175, 80, 0.3);
    }

    .status.error {
      background: rgba(244, 67, 54, 0.3);
    }

    #debugCanvas {
      border: 1px solid rgba(255,255,255,0.3);
      max-width: 100%;
    }

    .room-info {
      text-align: center;
      margin-bottom: 20px;
      padding: 15px;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
    }

    #roomId {
      font-family: monospace;
      font-size: 1.2em;
      color: #4CAF50;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ðŸŽ¥ VPS Video Call</h1>
    <p class="subtitle">WebGPU Motion Vectors Compression via WebSocket</p>
    
    <div class="room-info">
      <div>Room ID: <span id="roomId">Generating...</span></div>
      <div>Share this room ID with others to join the call</div>
    </div>

    <div class="status" id="status">Initializing WebGPU...</div>
    
    <div class="video-container">
      <div class="video-wrapper">
        <div class="video-label">ðŸ“¹ Local Video</div>
        <video id="localVideo" autoplay muted playsinline></video>
      </div>
      
      <div class="video-wrapper">
        <div class="video-label">ðŸ“¡ Remote Video</div>
        <canvas id="remoteCanvas"></canvas>
      </div>
    </div>
    
    <div class="controls">
      <button id="startBtn" onclick="startCall()">Start Call</button>
      <button id="stopBtn" onclick="stopCall()" disabled>Stop Call</button>
      
      <div class="resolution-control">
        <label>Resolution:</label>
        <input type="range" id="resolutionSlider" min="240" max="720" step="240" value="320">
        <span id="resolutionLabel">320x240</span>
      </div>
      
      <div class="resolution-control">
        <label>Send Rate:</label>
        <span id="sendRate">0 events/s</span>
      </div>
    </div>
    
    <div class="stats">
      <div class="stat-row">
        <span>Motion Events Sent:</span>
        <span id="eventsSent">0</span>
      </div>
      <div class="stat-row">
        <span>Motion Events Received:</span>
        <span id="eventsReceived">0</span>
      </div>
      <div class="stat-row">
        <span>Compression Ratio:</span>
        <span id="compressionRatio">0%</span>
      </div>
      <div class="stat-row">
        <span>WebSocket Status:</span>
        <span id="wsStatus">Disconnected</span>
      </div>
    </div>

    <canvas id="debugCanvas" style="display:none;"></canvas>
  </div>

  <script>
    // VPS WebSocket configuration
    const VPS_IP = '194.87.103.57';
    const WS_URL = `ws://${VPS_IP}/ws`;
    
    // WebGPU and video state
    let device, context, pipeline, bindGroup;
    let localStream, ws;
    let roomId, userId;
    let isStreaming = false;
    
    // Stats
    let eventsSent = 0;
    let eventsReceived = 0;
    let lastEventTime = Date.now();
    let eventsPerSecond = 0;
    
    // Generate room and user IDs
    roomId = window.location.hash.substr(1) || 'room-' + Math.random().toString(36).substr(2, 9);
    userId = 'user-' + Math.random().toString(36).substr(2, 9);
    document.getElementById('roomId').textContent = roomId;
    window.location.hash = roomId;
    
    // Initialize WebGPU
    async function initWebGPU() {
      if (!navigator.gpu) {
        throw new Error('WebGPU not supported');
      }
      
      const adapter = await navigator.gpu.requestAdapter();
      device = await adapter.requestDevice();
      
      const canvas = document.getElementById('debugCanvas');
      context = canvas.getContext('webgpu');
      context.configure({
        device: device,
        format: 'bgra8unorm'
      });
      
      updateStatus('WebGPU initialized', 'success');
      return true;
    }
    
    // Connect to WebSocket server
    function connectWebSocket() {
      const url = `${WS_URL}?room=${roomId}&id=${userId}`;
      updateStatus('Connecting to VPS...', 'info');
      
      ws = new WebSocket(url);
      
      ws.onopen = () => {
        updateStatus('Connected to VPS', 'connected');
        document.getElementById('wsStatus').textContent = 'Connected';
        
        // Request room users
        ws.send(JSON.stringify({ type: 'get-room-users' }));
      };
      
      ws.onmessage = (event) => {
        try {
          const msg = JSON.parse(event.data);
          handleServerMessage(msg);
        } catch (e) {
          console.error('Error parsing message:', e);
        }
      };
      
      ws.onerror = (error) => {
        updateStatus('WebSocket error', 'error');
        console.error('WebSocket error:', error);
      };
      
      ws.onclose = () => {
        updateStatus('Disconnected from VPS', 'error');
        document.getElementById('wsStatus').textContent = 'Disconnected';
        
        // Reconnect after 3 seconds
        if (isStreaming) {
          setTimeout(connectWebSocket, 3000);
        }
      };
    }
    
    // Handle messages from server
    function handleServerMessage(msg) {
      switch (msg.type) {
        case 'welcome':
          console.log('Welcome message received:', msg.data);
          break;
          
        case 'motion-events':
          if (msg.from !== userId) {
            handleRemoteMotionEvents(msg.events);
          }
          break;
          
        case 'user-joined':
          updateStatus(`User ${msg.from} joined the room`, 'info');
          break;
          
        case 'user-left':
          updateStatus(`User ${msg.from} left the room`, 'info');
          break;
          
        case 'room-users':
          console.log('Room users:', msg.data);
          break;
      }
    }
    
    // Process motion events from remote peer
    function handleRemoteMotionEvents(events) {
      if (!events || events.length === 0) return;
      
      eventsReceived += events.length;
      document.getElementById('eventsReceived').textContent = eventsReceived;
      
      const canvas = document.getElementById('remoteCanvas');
      const ctx = canvas.getContext('2d');
      
      // Process each motion event
      events.forEach(event => {
        if (event.d) {
          // Decode base64 image data
          const img = new Image();
          img.onload = () => {
            ctx.drawImage(img, event.x, event.y, event.s, event.s);
          };
          img.src = 'data:image/jpeg;base64,' + event.d;
        }
      });
    }
    
    // Start video call
    async function startCall() {
      try {
        // Initialize WebGPU if needed
        if (!device) {
          await initWebGPU();
        }
        
        // Get user media
        const resolution = parseInt(document.getElementById('resolutionSlider').value);
        localStream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: resolution,
            height: resolution * 0.75
          },
          audio: false
        });
        
        document.getElementById('localVideo').srcObject = localStream;
        
        // Set up canvas
        const remoteCanvas = document.getElementById('remoteCanvas');
        const video = document.getElementById('localVideo');
        remoteCanvas.width = resolution;
        remoteCanvas.height = resolution * 0.75;
        
        // Connect to WebSocket
        connectWebSocket();
        
        // Start processing frames
        isStreaming = true;
        processVideoFrames();
        
        // Update UI
        document.getElementById('startBtn').disabled = true;
        document.getElementById('stopBtn').disabled = false;
        
        updateStatus('Call started', 'connected');
        
      } catch (error) {
        console.error('Error starting call:', error);
        updateStatus('Error: ' + error.message, 'error');
      }
    }
    
    // Process video frames and detect motion
    function processVideoFrames() {
      if (!isStreaming) return;
      
      const video = document.getElementById('localVideo');
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = video.videoWidth || 320;
      canvas.height = video.videoHeight || 240;
      
      // Draw current frame
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      
      // Simple motion detection - send keyframe every second
      const now = Date.now();
      if (now - lastEventTime > 1000) {
        // Create motion events (simplified for demo)
        const blockSize = 32;
        const events = [];
        
        for (let y = 0; y < canvas.height; y += blockSize) {
          for (let x = 0; x < canvas.width; x += blockSize) {
            // Get block data
            const imageData = ctx.getImageData(x, y, blockSize, blockSize);
            
            // Convert to base64 JPEG
            const blockCanvas = document.createElement('canvas');
            blockCanvas.width = blockSize;
            blockCanvas.height = blockSize;
            const blockCtx = blockCanvas.getContext('2d');
            blockCtx.putImageData(imageData, 0, 0);
            
            const base64 = blockCanvas.toDataURL('image/jpeg', 0.7).split(',')[1];
            
            events.push({
              x: x,
              y: y,
              s: blockSize,
              d: base64
            });
          }
        }
        
        // Send events via WebSocket
        if (ws && ws.readyState === WebSocket.OPEN && events.length > 0) {
          ws.send(JSON.stringify({
            type: 'motion-events',
            events: events
          }));
          
          eventsSent += events.length;
          document.getElementById('eventsSent').textContent = eventsSent;
          
          // Update send rate
          eventsPerSecond = events.length;
          document.getElementById('sendRate').textContent = eventsPerSecond + ' events/s';
        }
        
        lastEventTime = now;
      }
      
      // Continue processing
      requestAnimationFrame(processVideoFrames);
    }
    
    // Stop video call
    function stopCall() {
      isStreaming = false;
      
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      
      if (ws) {
        ws.close();
        ws = null;
      }
      
      document.getElementById('startBtn').disabled = false;
      document.getElementById('stopBtn').disabled = true;
      
      updateStatus('Call ended', 'info');
    }
    
    // Update status message
    function updateStatus(message, type = 'info') {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = 'status ' + type;
    }
    
    // Resolution slider handler
    document.getElementById('resolutionSlider').addEventListener('input', (e) => {
      const value = e.target.value;
      const label = document.getElementById('resolutionLabel');
      label.textContent = `${value}x${Math.floor(value * 0.75)}`;
    });
    
    // Initialize on load
    window.addEventListener('load', async () => {
      try {
        await initWebGPU();
      } catch (error) {
        updateStatus('WebGPU not supported: ' + error.message, 'error');
      }
    });
  </script>
</body>
</html>