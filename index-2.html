<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Forest Friends Video Call</title>
  <style>
    #shaderCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      min-height: 100vh;
      overflow: hidden;
      background: #87CEEB;
      position: relative;
    }

    /* Voronoi + noise canopy effect */

    /* Animated background plants */
    .background-plants {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
    }

    .plant {
      position: absolute;
      bottom: 0;
      width: 60px;
      animation: sway 3s ease-in-out infinite;
      transform-origin: bottom center;
    }

    .plant::before {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 8px;
      height: 100%;
      background: linear-gradient(to top, #2d5016, #3a6218, #4a7c20);
      border-radius: 4px;
    }

    .leaf {
      position: absolute;
      width: 30px;
      height: 30px;
      background: radial-gradient(ellipse at bottom, #4a7c20, #5cb85c);
      border-radius: 0 100% 0 100%;
      transform-origin: bottom left;
    }

    /* Various plant sizes and densities */
    .plant-1 { left: 2%; height: 120px; animation-delay: 0s; width: 50px; }
    .plant-1 .leaf { width: 25px; height: 25px; }
    
    .plant-2 { left: 8%; height: 200px; animation-delay: 0.3s; width: 70px; }
    .plant-2 .leaf { width: 35px; height: 35px; }
    
    .plant-3 { left: 14%; height: 160px; animation-delay: 0.6s; width: 55px; }
    .plant-3 .leaf { width: 28px; height: 28px; }
    
    .plant-4 { left: 22%; height: 180px; animation-delay: 0.9s; width: 65px; }
    .plant-4 .leaf { width: 32px; height: 32px; }
    
    .plant-5 { left: 28%; height: 140px; animation-delay: 1.2s; width: 45px; }
    .plant-5 .leaf { width: 22px; height: 22px; }
    
    .plant-6 { left: 35%; height: 220px; animation-delay: 1.5s; width: 75px; }
    .plant-6 .leaf { width: 38px; height: 38px; }
    
    .plant-7 { left: 42%; height: 170px; animation-delay: 1.8s; width: 60px; }
    .plant-7 .leaf { width: 30px; height: 30px; }
    
    .plant-8 { left: 48%; height: 150px; animation-delay: 2.1s; width: 50px; }
    .plant-8 .leaf { width: 25px; height: 25px; }
    
    .plant-9 { left: 56%; height: 190px; animation-delay: 2.4s; width: 68px; }
    .plant-9 .leaf { width: 34px; height: 34px; }
    
    .plant-10 { left: 62%; height: 165px; animation-delay: 2.7s; width: 58px; }
    .plant-10 .leaf { width: 29px; height: 29px; }
    
    .plant-11 { left: 70%; height: 210px; animation-delay: 0.2s; width: 72px; }
    .plant-11 .leaf { width: 36px; height: 36px; }
    
    .plant-12 { left: 76%; height: 145px; animation-delay: 0.5s; width: 48px; }
    .plant-12 .leaf { width: 24px; height: 24px; }
    
    .plant-13 { left: 84%; height: 175px; animation-delay: 0.8s; width: 62px; }
    .plant-13 .leaf { width: 31px; height: 31px; }
    
    .plant-14 { left: 90%; height: 155px; animation-delay: 1.1s; width: 52px; }
    .plant-14 .leaf { width: 26px; height: 26px; }
    
    .plant-15 { left: 96%; height: 185px; animation-delay: 1.4s; width: 64px; }
    .plant-15 .leaf { width: 32px; height: 32px; }

    /* Generic leaf positioning for all plants */
    .plant .leaf:nth-child(1) { bottom: 20%; transform: rotate(-35deg); left: 3px; }
    .plant .leaf:nth-child(2) { bottom: 40%; transform: rotate(40deg) scaleX(-1); right: 3px; }
    .plant .leaf:nth-child(3) { bottom: 60%; transform: rotate(-30deg); left: 5px; }
    .plant .leaf:nth-child(4) { bottom: 80%; transform: rotate(35deg) scaleX(-1); right: 5px; }

    @keyframes sway {
      0%, 100% { transform: rotate(-2deg); }
      50% { transform: rotate(2deg); }
    }

    /* Floating particles/pollen */
    .particle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: rgba(255, 255, 200, 0.8);
      border-radius: 50%;
      animation: float 15s infinite;
    }

    .particle:nth-child(5) { left: 10%; animation-delay: 0s; animation-duration: 13s; }
    .particle:nth-child(6) { left: 30%; animation-delay: 2s; animation-duration: 17s; }
    .particle:nth-child(7) { left: 50%; animation-delay: 4s; animation-duration: 14s; }
    .particle:nth-child(8) { left: 70%; animation-delay: 1s; animation-duration: 16s; }
    .particle:nth-child(9) { left: 90%; animation-delay: 3s; animation-duration: 15s; }

    @keyframes float {
      0% {
        transform: translateY(100vh) rotate(0deg);
        opacity: 0;
      }
      10% {
        opacity: 1;
      }
      90% {
        opacity: 1;
      }
      100% {
        transform: translateY(-100vh) rotate(360deg);
        opacity: 0;
      }
    }

    /* Main content */
    .container {
      position: relative;
      z-index: 10;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    /* Title with forest theme */
    .title {
      font-size: 3.5em;
      font-weight: bold;
      color: #2d5016;
      text-align: center;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
      animation: titleAppear 1s ease-out;
    }

    .subtitle {
      font-size: 1.2em;
      color: #3a6218;
      margin-bottom: 40px;
      text-align: center;
      animation: titleAppear 1s ease-out 0.2s backwards;
    }

    @keyframes titleAppear {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Avatar selection card */
    .selection-card {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      padding: 40px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.15);
      max-width: 800px;
      width: 100%;
      animation: cardAppear 1s ease-out 0.4s backwards;
    }

    @keyframes cardAppear {
      from {
        opacity: 0;
        transform: scale(0.9);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .card-title {
      font-size: 1.5em;
      color: #2d5016;
      text-align: center;
      margin-bottom: 30px;
      font-weight: 600;
    }

    /* Avatar grid */
    .avatar-grid {
      display: flex;
      justify-content: center;
      gap: 40px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }

    .avatar-option {
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
      animation: avatarBounce 2s ease-in-out infinite;
      animation-play-state: paused;
    }

    .avatar-option:hover {
      animation-play-state: running;
      transform: translateY(-5px);
    }

    .avatar-option:nth-child(1) { animation-delay: 0s; }
    .avatar-option:nth-child(2) { animation-delay: 0.2s; }
    .avatar-option:nth-child(3) { animation-delay: 0.4s; }

    @keyframes avatarBounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    .avatar-image {
      width: 140px;
      height: 140px;
      border-radius: 50%;
      object-fit: cover;
      border: 4px solid transparent;
      transition: all 0.3s ease;
      box-shadow: 0 5px 20px rgba(0,0,0,0.1);
    }

    .avatar-option:hover .avatar-image {
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
      border-color: #90EE90;
    }

    .avatar-selected .avatar-image {
      border-color: #4a7c20 !important;
      box-shadow: 0 0 0 3px rgba(74, 124, 32, 0.2);
    }

    .avatar-name {
      margin-top: 12px;
      font-size: 1.1em;
      font-weight: 600;
      color: #2d5016;
    }

    .avatar-option.disabled {
      opacity: 0.4;
      pointer-events: none;
    }

    .avatar-option.disabled .avatar-name::after {
      content: " (In Call)";
      color: #999;
      font-size: 0.9em;
    }

    /* Join button */
    .join-button {
      background: linear-gradient(135deg, #4a7c20, #5cb85c);
      color: white;
      border: none;
      padding: 15px 40px;
      font-size: 1.2em;
      font-weight: 600;
      border-radius: 30px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 20px rgba(74, 124, 32, 0.3);
      display: block;
      margin: 0 auto;
    }

    .join-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 30px rgba(74, 124, 32, 0.4);
      background: linear-gradient(135deg, #5cb85c, #4a7c20);
    }

    .join-button:active {
      transform: translateY(0);
    }

    .join-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .hidden {
      display: none !important;
    }

    /* Error message */
    .error-message {
      color: #d9534f;
      text-align: center;
      margin-top: 15px;
      font-weight: 500;
      animation: shake 0.5s;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }

    /* Video grid (hidden initially) */
    #videoGrid {
      display: none;
      width: 100%;
      height: 100vh;
      background: linear-gradient(135deg, #2d5016, #3a6218);
      padding: 20px;
      grid-gap: 15px;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 100;
    }

    .videoContainer {
      position: relative;
      background: #000;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }

    .videoContainer video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .peerId {
      position: absolute;
      bottom: 15px;
      left: 15px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 8px 15px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 500;
    }

  </style>
</head>
<body>
  <!-- WebGL Shader Background -->
  <canvas id="shaderCanvas"></canvas>
  <!-- Animated background with more plants -->
  <div class="background-plants">
    <div class="plant plant-1">
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
    </div>
    <div class="plant plant-2">
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
    </div>
    <div class="plant plant-3">
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
    </div>
    <div class="plant plant-4">
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
    </div>
    <div class="plant plant-5">
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
    </div>
    <div class="plant plant-6">
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
    </div>
    <div class="plant plant-7">
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
    </div>
    <div class="plant plant-8">
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
    </div>
    <div class="plant plant-9">
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
    </div>
    <div class="plant plant-10">
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
    </div>
    <div class="plant plant-11">
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
    </div>
    <div class="plant plant-12">
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
    </div>
    <div class="plant plant-13">
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
    </div>
    <div class="plant plant-14">
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
    </div>
    <div class="plant plant-15">
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
      <div class="leaf"></div>
    </div>
    <!-- Floating particles -->
    <div class="particle"></div>
    <div class="particle"></div>
    <div class="particle"></div>
    <div class="particle"></div>
    <div class="particle"></div>
  </div>


  <!-- Main content -->
  <div class="container">
    <h1 class="title">ðŸŒ¿ Forest Friends Video Call ðŸŒ¿</h1>
    <p class="subtitle">Choose your forest friend to join the call</p>
    
    <div class="selection-card">
      <h2 class="card-title">Select Your Avatar</h2>
      <div id="userSelection" class="avatar-grid"></div>
      <div id="errorMessage" class="error-message"></div>
      <button id="joinButton" class="join-button hidden">Join the Forest Call ðŸŒ²</button>
    </div>
  </div>

  <!-- Video grid (hidden until joined) -->
  <div id="videoGrid"></div>

  <script>
    // =========================================================================
    // WEBGL SHADER SETUP
    // =========================================================================
    function initShader() {
      const canvas = document.getElementById('shaderCanvas');
      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      
      if (!gl) {
        console.error('WebGL not supported');
        return;
      }

      // Vertex shader
      const vertexShaderSource = `
        attribute vec2 a_position;
        void main() {
          gl_Position = vec4(a_position, 0.0, 1.0);
        }
      `;

      // Fragment shader (adapted from the Shadertoy)
      const fragmentShaderSource = `
        precision mediump float;
        uniform vec2 u_resolution;
        uniform float u_time;

        vec2 hash2(vec2 p) {
          p = vec2(dot(p, vec2(127.1, 311.7)),
                   dot(p, vec2(269.5, 183.3)));
          return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
        }

        float noise(vec2 p) {
          const float K1 = 0.366025404; // (sqrt(3)-1)/2;
          const float K2 = 0.211324865; // (3-sqrt(3))/6;
          
          vec2 i = floor(p + (p.x + p.y) * K1);
          vec2 a = p - i + (i.x + i.y) * K2;
          vec2 o = (a.x > a.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
          vec2 b = a - o + K2;
          vec2 c = a - 1.0 + 2.0 * K2;
          
          vec3 h = max(0.5 - vec3(dot(a,a), dot(b,b), dot(c,c)), 0.0);
          vec3 n = h * h * h * h * vec3(dot(a, hash2(i + 0.0)), 
                                         dot(b, hash2(i + o)),
                                         dot(c, hash2(i + 1.0)));
          return dot(n, vec3(70.0));
        }

        vec3 voronoi(vec2 x) {
          vec2 n = floor(x);
          vec2 f = fract(x);
          
          vec2 mg, mr;
          float md = 8.0;
          for(int j = -1; j <= 1; j++) {
            for(int i = -1; i <= 1; i++) {
              vec2 g = vec2(float(i), float(j));
              vec2 o = hash2(n + g);
              vec2 r = g + o - f;
              float d = dot(r, r);
              
              if(d < md) {
                md = d;
                mr = r;
                mg = g;
              }
            }
          }
          
          md = 8.0;
          for(int j = -2; j <= 2; j++) {
            for(int i = -2; i <= 2; i++) {
              vec2 g = mg + vec2(float(i), float(j));
              vec2 o = hash2(n + g);
              vec2 r = g + o - f;
              
              if(dot(mr - r, mr - r) > 0.00001)
                md = min(md, dot(0.5 * (mr + r), normalize(r - mr)));
            }
          }
          
          return vec3(md, mr);
        }

        void main() {
          vec2 p = gl_FragCoord.xy / u_resolution.xy;
          p.y = 1.0 - p.y; // Flip Y for looking up
          
          // Create movement
          float time = u_time * 0.5;
          p += vec2(sin(time * 0.1) * 0.02, cos(time * 0.15) * 0.03);
          
          // Multiple layers of voronoi for depth
          vec3 v1 = voronoi(8.0 * p + vec2(time * 0.1, 0.0));
          vec3 v2 = voronoi(16.0 * p + vec2(0.0, time * 0.05));
          vec3 v3 = voronoi(32.0 * p + vec2(time * 0.02, time * 0.03));
          
          // Add noise for organic feel
          float n = noise(p * 20.0 + time * 0.2) * 0.5 + 0.5;
          
          // Combine layers
          float leafDensity = smoothstep(0.0, 0.7, v1.x) * 
                              smoothstep(0.0, 0.5, v2.x) * 
                              (0.5 + 0.5 * smoothstep(0.0, 0.3, v3.x));
          
          // Mix colors: sky blue through to green leaves
          vec3 skyColor = vec3(0.53, 0.81, 0.92); // Sky blue
          vec3 leafColor = mix(
            vec3(0.18, 0.38, 0.09), // Dark green
            vec3(0.29, 0.49, 0.12), // Medium green
            n
          );
          
          // Add slight variation to leaf color
          leafColor = mix(leafColor, vec3(0.36, 0.54, 0.36), smoothstep(0.3, 0.7, v2.x));
          
          // Final color
          vec3 color = mix(skyColor, leafColor, leafDensity);
          
          // Add subtle lighting
          color += vec3(0.1, 0.15, 0.05) * (1.0 - leafDensity) * n;
          
          gl_FragColor = vec4(color, 1.0);
        }
      `;

      // Compile shaders
      function compileShader(gl, source, type) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error('Shader compile error:', gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
      const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);

      // Create program
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program link error:', gl.getProgramInfoLog(program));
        return;
      }

      // Set up geometry (full screen quad)
      const positions = new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
         1,  1,
      ]);

      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

      const positionLocation = gl.getAttribLocation(program, 'a_position');
      const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
      const timeLocation = gl.getUniformLocation(program, 'u_time');

      // Resize canvas
      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
      }
      
      resize();
      window.addEventListener('resize', resize);

      // Render loop
      function render(time) {
        time *= 0.001; // Convert to seconds

        gl.useProgram(program);

        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
        gl.uniform1f(timeLocation, time);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        requestAnimationFrame(render);
      }

      requestAnimationFrame(render);
    }

    // Initialize shader on load
    window.addEventListener('load', initShader);
  </script>

  <script>
    // =========================================================================
    // CONFIG & STATE
    // =========================================================================
    const JSONBIN_API_KEY = '$2a$10$RWXovJmFo.sJ0tRptHowp.2vluFhdI6ds1R4fILpL.Bq09q4SZ6FS';
    const JSONBIN_BIN_ID = '689cb5b0ae596e708fc94426';
    const SIGNALING_SERVER = `https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}`;

    const users = [
      { name: "Miguel", avatar: "avatar-0.webp", emoji: "ðŸ¦”" },
      { name: "Anastasiia", avatar: "avatar-6.webp", emoji: "ðŸ¿ï¸" },
      { name: "Mariana", avatar: "avatar-5.webp", emoji: "ðŸ¦œ" }
    ];

    let myUuid = null;
    let localStream = null;
    const peers = new Map();
    let isPolling = false;

    const iceServers = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    };

    // =========================================================================
    // INITIALIZATION
    // =========================================================================
    window.addEventListener('load', async () => {
      try {
        const activePeers = await fetchActivePeers();
        showUserSelection(users, activePeers);
      } catch (error) {
        console.log('Starting in offline mode');
        showUserSelection(users, []);
      }
    });

    async function fetchActivePeers() {
      try {
        const resp = await fetch(SIGNALING_SERVER + '/latest', {
          method: 'GET',
          headers: {
            'X-Master-Key': JSONBIN_API_KEY,
            'Content-Type': 'application/json'
          }
        });
        if (!resp.ok) {
          throw new Error(`Failed to fetch: ${resp.status}`);
        }
        const data = await resp.json();
        const record = data.record || {};
        const now = Date.now();
        const activePeers = [];
        for (const [peer, timestamp] of Object.entries(record.peers || {})) {
          if (now - timestamp < 30000) {
            activePeers.push(peer);
          }
        }
        return activePeers;
      } catch (error) {
        console.log('Using local-only mode:', error.message);
        return [];
      }
    }

    function showUserSelection(allUsers, takenList) {
      const userSelectionDiv = document.getElementById('userSelection');
      userSelectionDiv.innerHTML = '';

      allUsers.forEach(u => {
        const wrapper = document.createElement('div');
        wrapper.className = 'avatar-option';
        
        if (takenList.includes(u.name)) {
          wrapper.classList.add('disabled');
        }

        const img = document.createElement('img');
        img.src = u.avatar;
        img.alt = u.name;
        img.className = 'avatar-image';

        const label = document.createElement('div');
        label.className = 'avatar-name';
        label.textContent = `${u.emoji} ${u.name}`;

        wrapper.onclick = () => {
          if (wrapper.classList.contains('disabled')) return;
          
          document.querySelectorAll('.avatar-option').forEach(el => 
            el.classList.remove('avatar-selected')
          );
          wrapper.classList.add('avatar-selected');
          
          myUuid = u.name;
          document.getElementById('errorMessage').textContent = '';
          document.getElementById('joinButton').classList.remove('hidden');
        };

        wrapper.appendChild(img);
        wrapper.appendChild(label);
        userSelectionDiv.appendChild(wrapper);
      });
    }

    // =========================================================================
    // JOIN CALL
    // =========================================================================
    document.getElementById('joinButton').onclick = async function() {
      if (!myUuid) {
        document.getElementById('errorMessage').textContent = 'Please select an avatar!';
        return;
      }

      this.disabled = true;
      document.getElementById('errorMessage').textContent = '';

      try {
        // Get camera/mic
        localStream = await navigator.mediaDevices.getUserMedia({ 
          video: true, 
          audio: true 
        });

        // Register with signaling
        await registerPeer(myUuid);

        // Switch to video view
        document.querySelector('.container').style.display = 'none';
        document.querySelector('.background-plants').style.display = 'none';
        
        const videoGrid = document.getElementById('videoGrid');
        videoGrid.style.display = 'grid';
        videoGrid.style.gridTemplateColumns = '1fr';

        // Add local video
        createVideoContainer(myUuid, localStream, true);

        // Start polling for peers
        isPolling = true;
        pollLoop();

      } catch (err) {
        this.disabled = false;
        document.getElementById('errorMessage').textContent = 
          'Error: ' + err.message;
      }
    };

    async function registerPeer(uuid) {
      try {
        const getResp = await fetch(SIGNALING_SERVER + '/latest', {
          headers: { 'X-Master-Key': JSONBIN_API_KEY }
        });
        const data = await getResp.json();
        const record = data.record || { peers: {}, messages: {} };
        
        record.peers = record.peers || {};
        record.peers[uuid] = Date.now();
        record.messages = record.messages || {};
        record.messages[uuid] = [];
        
        const updateResp = await fetch(SIGNALING_SERVER, {
          method: 'PUT',
          headers: {
            'X-Master-Key': JSONBIN_API_KEY,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(record)
        });
        
        if (!updateResp.ok) {
          throw new Error(`Registration failed: ${updateResp.status}`);
        }
        console.log('Registered with signaling server');
        return { uuid, registered: true };
      } catch (error) {
        console.log('Registration error - continuing in local mode');
        return { uuid, registered: false };
      }
    }

    async function pollLoop() {
      if (!isPolling) return;

      try {
        const activePeers = await fetchActivePeers();
        
        // Create connections for new peers
        for (const peerUuid of activePeers) {
          if (peerUuid === myUuid) continue;
          if (myUuid < peerUuid && !peers.has(peerUuid)) {
            await createPeerConnection(peerUuid, true);
          }
        }

        // Poll for messages
        const messages = await pollMessages();
        for (const msg of messages) {
          await handleSignalMessage(msg);
        }
      } catch (err) {
        console.error('Polling error:', err);
      }

      setTimeout(pollLoop, 2000);
    }

    async function pollMessages() {
      try {
        const resp = await fetch(SIGNALING_SERVER + '/latest', {
          headers: { 'X-Master-Key': JSONBIN_API_KEY }
        });
        if (!resp.ok) {
          throw new Error(`Poll failed: ${resp.status}`);
        }
        const data = await resp.json();
        const record = data.record || { messages: {} };
        const myMessages = record.messages?.[myUuid] || [];
        
        if (myMessages.length > 0) {
          record.messages[myUuid] = [];
          await fetch(SIGNALING_SERVER, {
            method: 'PUT',
            headers: {
              'X-Master-Key': JSONBIN_API_KEY,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(record)
          });
        }
        return myMessages;
      } catch (error) {
        return [];
      }
    }

    async function sendToPeer(targetUuid, type, data) {
      try {
        const getResp = await fetch(SIGNALING_SERVER + '/latest', {
          headers: { 'X-Master-Key': JSONBIN_API_KEY }
        });
        const result = await getResp.json();
        const record = result.record || { messages: {} };
        
        record.messages = record.messages || {};
        record.messages[targetUuid] = record.messages[targetUuid] || [];
        record.messages[targetUuid].push({ type, data, from: myUuid });
        
        await fetch(SIGNALING_SERVER, {
          method: 'PUT',
          headers: {
            'X-Master-Key': JSONBIN_API_KEY,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(record)
        });
      } catch (err) {
        console.error('Send error:', err);
      }
    }

    // =========================================================================
    // WEBRTC
    // =========================================================================
    async function createPeerConnection(targetUuid, createOffer) {
      if (peers.has(targetUuid)) return peers.get(targetUuid);

      const pc = new RTCPeerConnection(iceServers);
      peers.set(targetUuid, pc);

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          sendToPeer(targetUuid, 'ice-candidate', event.candidate);
        }
      };

      pc.ontrack = (event) => {
        createVideoContainer(targetUuid, event.streams[0], false);
      };

      if (localStream) {
        localStream.getTracks().forEach(track => {
          pc.addTrack(track, localStream);
        });
      }

      if (createOffer) {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await sendToPeer(targetUuid, 'offer', offer);
      }

      return pc;
    }

    async function handleSignalMessage(msg) {
      const { type, data, from } = msg;

      try {
        switch (type) {
          case 'offer': {
            const pc = await createPeerConnection(from, false);
            await pc.setRemoteDescription(new RTCSessionDescription(data));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            await sendToPeer(from, 'answer', answer);
            break;
          }
          case 'answer': {
            const pc = peers.get(from);
            if (pc) {
              await pc.setRemoteDescription(new RTCSessionDescription(data));
            }
            break;
          }
          case 'ice-candidate': {
            const pc = peers.get(from);
            if (pc) {
              await pc.addIceCandidate(new RTCIceCandidate(data));
            }
            break;
          }
        }
      } catch (err) {
        console.error('Error handling signal:', err);
      }
    }

    function createVideoContainer(uuid, stream, isLocal) {
      let container = document.getElementById(`video-${uuid}`);
      
      if (!container) {
        container = document.createElement('div');
        container.className = 'videoContainer';
        container.id = `video-${uuid}`;

        const video = document.createElement('video');
        video.autoplay = true;
        video.playsInline = true;
        if (isLocal) video.muted = true;

        const label = document.createElement('div');
        label.className = 'peerId';
        const user = users.find(u => u.name === uuid);
        label.textContent = user ? `${user.emoji} ${uuid}` : uuid;
        if (isLocal) label.textContent += ' (You)';

        container.appendChild(video);
        container.appendChild(label);
        document.getElementById('videoGrid').appendChild(container);

        adjustGridLayout();
      }

      const video = container.querySelector('video');
      if (video.srcObject !== stream) {
        video.srcObject = stream;
      }
    }

    function adjustGridLayout() {
      const grid = document.getElementById('videoGrid');
      const count = grid.querySelectorAll('.videoContainer').length;
      
      if (count <= 1) {
        grid.style.gridTemplateColumns = '1fr';
      } else if (count === 2) {
        grid.style.gridTemplateColumns = '1fr 1fr';
      } else if (count <= 4) {
        grid.style.gridTemplateColumns = '1fr 1fr';
      } else {
        grid.style.gridTemplateColumns = '1fr 1fr 1fr';
      }
    }

    // Cleanup on exit
    window.addEventListener('beforeunload', async () => {
      isPolling = false;
      if (myUuid) {
        try {
          const getResp = await fetch(SIGNALING_SERVER + '/latest', {
            headers: { 'X-Master-Key': JSONBIN_API_KEY }
          });
          const data = await getResp.json();
          const record = data.record || {};
          if (record.peers && record.peers[myUuid]) {
            delete record.peers[myUuid];
            delete record.messages[myUuid];
            await fetch(SIGNALING_SERVER, {
              method: 'PUT',
              headers: {
                'X-Master-Key': JSONBIN_API_KEY,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(record)
            });
          }
        } catch (err) {
          console.error('Cleanup error:', err);
        }
      }
      peers.forEach(pc => pc.close());
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
      }
    });
  </script>
</body>
</html>