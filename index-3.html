<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Forest Friends Video Call - Shader Background</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      min-height: 100vh;
      overflow: hidden;
      position: relative;
    }

    #shaderCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    /* Main content */
    .container {
      position: relative;
      z-index: 10;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    /* Title with forest theme */
    .title {
      font-size: 3.5em;
      font-weight: bold;
      color: white;
      text-align: center;
      margin-bottom: 10px;
      text-shadow: 2px 2px 8px rgba(0,0,0,0.5);
      animation: titleAppear 1s ease-out;
    }

    .subtitle {
      font-size: 1.2em;
      color: white;
      margin-bottom: 40px;
      text-align: center;
      text-shadow: 1px 1px 4px rgba(0,0,0,0.5);
      animation: titleAppear 1s ease-out 0.2s backwards;
    }

    @keyframes titleAppear {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Avatar selection card */
    .selection-card {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      padding: 40px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.15);
      max-width: 800px;
      width: 100%;
      animation: cardAppear 1s ease-out 0.4s backwards;
    }

    @keyframes cardAppear {
      from {
        opacity: 0;
        transform: scale(0.9);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .card-title {
      font-size: 1.5em;
      color: #2d5016;
      text-align: center;
      margin-bottom: 30px;
      font-weight: 600;
    }

    /* Avatar grid */
    .avatar-grid {
      display: flex;
      justify-content: center;
      gap: 40px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }

    .avatar-option {
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
    }

    .avatar-option:hover {
      transform: translateY(-5px);
    }

    .avatar-image {
      width: 140px;
      height: 140px;
      border-radius: 50%;
      object-fit: cover;
      border: 4px solid transparent;
      transition: all 0.3s ease;
      box-shadow: 0 5px 20px rgba(0,0,0,0.1);
    }

    .avatar-option:hover .avatar-image {
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
      border-color: #90EE90;
    }

    .avatar-selected .avatar-image {
      border-color: #4a7c20 !important;
      box-shadow: 0 0 0 3px rgba(74, 124, 32, 0.2);
    }

    .avatar-name {
      margin-top: 12px;
      font-size: 1.1em;
      font-weight: 600;
      color: #2d5016;
    }

    .avatar-option.disabled {
      opacity: 0.4;
      pointer-events: none;
    }

    .avatar-option.disabled .avatar-name::after {
      content: " (In Call)";
      color: #999;
      font-size: 0.9em;
    }

    /* Join button */
    .join-button {
      background: linear-gradient(135deg, #4a7c20, #5cb85c);
      color: white;
      border: none;
      padding: 15px 40px;
      font-size: 1.2em;
      font-weight: 600;
      border-radius: 30px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 20px rgba(74, 124, 32, 0.3);
      display: block;
      margin: 0 auto;
    }

    .join-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 30px rgba(74, 124, 32, 0.4);
      background: linear-gradient(135deg, #5cb85c, #4a7c20);
    }

    .join-button:active {
      transform: translateY(0);
    }

    .join-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .hidden {
      display: none !important;
    }

    /* Error message */
    .error-message {
      color: #d9534f;
      text-align: center;
      margin-top: 15px;
      font-weight: 500;
    }

    /* Video grid (hidden initially) */
    #videoGrid {
      display: none;
      width: 100%;
      height: 100vh;
      background: rgba(0,0,0,0.8);
      padding: 20px;
      grid-gap: 15px;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 100;
    }

    .videoContainer {
      position: relative;
      background: #000;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }

    .videoContainer video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .peerId {
      position: absolute;
      bottom: 15px;
      left: 15px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 8px 15px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 500;
    }
  </style>
</head>
<body>
  <!-- WebGL Shader Background -->
  <canvas id="shaderCanvas"></canvas>

  <!-- Main content -->
  <div class="container">
    <h1 class="title">🌿 Forest Friends Video Call 🌿</h1>
    <p class="subtitle">Choose your forest friend to join the call</p>
    
    <div class="selection-card">
      <h2 class="card-title">Select Your Avatar</h2>
      <div id="userSelection" class="avatar-grid"></div>
      <div id="errorMessage" class="error-message"></div>
      <button id="joinButton" class="join-button hidden">Join the Forest Call 🌲</button>
    </div>
  </div>

  <!-- Video grid (hidden until joined) -->
  <div id="videoGrid"></div>

  <script>
    // =========================================================================
    // WEBGL SHADER SETUP - Canopy shader from Shadertoy
    // =========================================================================
    function initShader() {
      const canvas = document.getElementById('shaderCanvas');
      const gl = canvas.getContext('webgl2') || canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      
      if (!gl) {
        console.error('WebGL not supported');
        // Fallback to solid color
        canvas.style.background = 'linear-gradient(180deg, #87CEEB 0%, #98D98E 50%, #90EE90 100%)';
        return;
      }

      // Vertex shader - simple quad
      const vertexShaderSource = `
        attribute vec2 a_position;
        varying vec2 v_texCoord;
        
        void main() {
          gl_Position = vec4(a_position, 0.0, 1.0);
          v_texCoord = a_position * 0.5 + 0.5;
        }
      `;

      // Fragment shader - canopy with clouds
      const fragmentShaderSource = `
        precision highp float;
        
        uniform vec2 u_resolution;
        uniform float u_time;
        varying vec2 v_texCoord;
        
        // Hash functions for procedural noise
        float hash1(vec2 p) {
          p = 50.0 * fract(p * 0.3183099);
          return fract(p.x * p.y * (p.x + p.y));
        }
        
        float hash1(float n) {
          return fract(n * 17.0 * fract(n * 0.3183099));
        }
        
        vec2 hash2(vec2 p) {
          const vec2 k = vec2(0.3183099, 0.3678794);
          float n = 111.0 * p.x + 113.0 * p.y;
          return fract(n * fract(k * n));
        }
        
        // Simple noise function
        float noise(vec2 x) {
          vec2 p = floor(x);
          vec2 w = fract(x);
          vec2 u = w * w * (3.0 - 2.0 * w);
          
          float a = hash1(p + vec2(0, 0));
          float b = hash1(p + vec2(1, 0));
          float c = hash1(p + vec2(0, 1));
          float d = hash1(p + vec2(1, 1));
          
          return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
        }
        
        // Fractal Brownian Motion
        float fbm(vec2 x) {
          float v = 0.0;
          float a = 0.5;
          vec2 shift = vec2(100.0);
          mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));
          
          for (int i = 0; i < 5; i++) {
            v += a * noise(x);
            x = rot * x * 2.0 + shift;
            a *= 0.5;
          }
          return v;
        }
        
        // Cloud FBM with more octaves for fluffiness
        float cloudFbm(vec2 x) {
          float v = 0.0;
          float a = 0.5;
          vec2 shift = vec2(100.0);
          mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));
          
          for (int i = 0; i < 7; i++) {
            v += a * noise(x);
            x = rot * x * 2.0 + shift;
            a *= 0.6;
          }
          return v;
        }
        
        // Voronoi for leaf patterns
        vec3 voronoi(vec2 x) {
          vec2 n = floor(x);
          vec2 f = fract(x);
          
          float md = 8.0;
          vec2 mg, mr;
          
          for(int j = -1; j <= 1; j++) {
            for(int i = -1; i <= 1; i++) {
              vec2 g = vec2(float(i), float(j));
              vec2 o = hash2(n + g);
              vec2 r = g + o - f;
              float d = dot(r, r);
              
              if(d < md) {
                md = d;
                mr = r;
                mg = g;
              }
            }
          }
          
          return vec3(md, mr);
        }
        
        // Cloud layer function
        vec3 renderClouds(vec2 p, float time) {
          // Cloud movement
          vec2 cloudPos = p * 0.3 + vec2(time * 0.02, time * 0.01);
          
          // Multiple cloud layers for depth
          float cloud1 = cloudFbm(cloudPos * 2.0);
          float cloud2 = cloudFbm(cloudPos * 4.0 + vec2(100.0, 200.0));
          float cloud3 = cloudFbm(cloudPos * 8.0 + vec2(300.0, 100.0));
          
          // Combine cloud layers
          float clouds = cloud1 * 0.5 + cloud2 * 0.3 + cloud3 * 0.2;
          clouds = smoothstep(0.3, 0.7, clouds);
          
          // Cloud color (white to light gray)
          vec3 cloudColor = mix(
            vec3(0.9, 0.9, 0.95),  // Light gray
            vec3(1.0, 1.0, 1.0),    // White
            clouds
          );
          
          return cloudColor * clouds;
        }
        
        void main() {
          vec2 uv = gl_FragCoord.xy / u_resolution.xy;
          
          // Camera looking up at canopy
          vec2 p = (uv - 0.5) * 4.0;
          p.x *= u_resolution.x / u_resolution.y;
          
          float time = u_time * 0.05;
          
          // Sky and clouds layer (background)
          vec3 skyColor = vec3(0.53, 0.81, 0.92);
          vec3 clouds = renderClouds(p, u_time);
          vec3 skyWithClouds = mix(skyColor, vec3(1.0), clouds.r * 0.7);
          
          // Canopy movement - different speeds for each layer
          float windX1 = sin(time * 0.7) * 0.05 + sin(time * 1.3) * 0.02;
          float windY1 = cos(time * 0.5) * 0.03 + cos(time * 1.1) * 0.02;
          
          float windX2 = sin(time * 0.9 + 1.0) * 0.04;
          float windY2 = cos(time * 0.6 + 1.0) * 0.04;
          
          float windX3 = sin(time * 1.1 + 2.0) * 0.03;
          float windY3 = cos(time * 0.8 + 2.0) * 0.03;
          
          // Create canopy layers with individual movement
          vec3 v1 = voronoi((p + vec2(windX1, windY1)) * 6.0 + vec2(time * 0.3, 0.0));
          vec3 v2 = voronoi((p + vec2(windX2, windY2)) * 12.0 + vec2(0.0, time * 0.2));
          vec3 v3 = voronoi((p + vec2(windX3, windY3)) * 24.0 + vec2(time * 0.1, time * 0.15));
          
          // Combine voronoi cells for leaf coverage
          float leaves = smoothstep(0.0, 0.4, v1.x) * 
                        smoothstep(0.0, 0.3, v2.x) * 
                        (0.7 + 0.3 * smoothstep(0.0, 0.2, v3.x));
          
          // Add organic variation with noise
          float n = fbm(p * 8.0 + time * 0.1);
          leaves *= 0.8 + 0.4 * n;
          leaves = clamp(leaves, 0.0, 1.0);
          
          // Leaf colors with variation
          vec3 leafColor = mix(
            vec3(0.12, 0.28, 0.05), // Dark green
            vec3(0.22, 0.42, 0.12), // Medium green
            n
          );
          
          // Add some yellow-green variation for realism
          float leafVariation = noise(p * 30.0 + time * 0.05);
          leafColor = mix(leafColor, vec3(0.3, 0.45, 0.1), leafVariation * 0.3);
          
          // Shadow from clouds on leaves
          float cloudShadow = 1.0 - clouds.r * 0.3;
          leafColor *= cloudShadow;
          
          // Sunlight filtering through gaps
          float sunlight = 1.0 - leaves;
          sunlight *= 0.5 + 0.5 * noise(p * 16.0 + time);
          
          // Mix sky/clouds with leaves
          vec3 color = mix(skyWithClouds, leafColor, leaves);
          
          // Add sun rays through the canopy
          vec2 sunPos = vec2(0.3, -0.5);
          float rays = pow(max(0.0, 1.0 - length(p + sunPos) * 0.3), 3.0);
          color += vec3(1.0, 0.95, 0.8) * rays * sunlight * 0.4;
          
          // God rays effect
          float godRays = 0.0;
          for(float i = 0.0; i < 3.0; i++) {
            vec2 rayPos = p + sunPos * (1.0 + i * 0.1);
            godRays += pow(max(0.0, 1.0 - length(rayPos) * 0.5), 2.0) * (1.0 - leaves);
          }
          color += vec3(1.0, 0.9, 0.7) * godRays * 0.05;
          
          // Add atmospheric perspective
          color = mix(color, skyWithClouds, length(p) * 0.08);
          
          // Subtle vignette
          float vignette = 1.0 - length(uv - 0.5) * 0.4;
          color *= vignette;
          
          // Color grading for more natural look
          color = pow(color, vec3(0.95)); // Slight gamma correction
          color = mix(color, vec3(dot(color, vec3(0.299, 0.587, 0.114))), -0.1); // Slight saturation boost
          
          gl_FragColor = vec4(color, 1.0);
        }
      `;

      // Compile shaders
      function compileShader(gl, source, type) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error('Shader compile error:', gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
      const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);

      if (!vertexShader || !fragmentShader) {
        canvas.style.background = 'linear-gradient(180deg, #87CEEB 0%, #98D98E 50%, #90EE90 100%)';
        return;
      }

      // Create program
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program link error:', gl.getProgramInfoLog(program));
        canvas.style.background = 'linear-gradient(180deg, #87CEEB 0%, #98D98E 50%, #90EE90 100%)';
        return;
      }

      // Set up geometry (full screen quad)
      const positions = new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
         1,  1,
      ]);

      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

      const positionLocation = gl.getAttribLocation(program, 'a_position');
      const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
      const timeLocation = gl.getUniformLocation(program, 'u_time');

      // Resize canvas
      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
      }
      
      resize();
      window.addEventListener('resize', resize);

      // Render loop
      function render(time) {
        time *= 0.001; // Convert to seconds

        gl.useProgram(program);

        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
        gl.uniform1f(timeLocation, time);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        requestAnimationFrame(render);
      }

      requestAnimationFrame(render);
    }

    // Initialize shader immediately
    initShader();

    // =========================================================================
    // VIDEO CALL APPLICATION
    // =========================================================================
    const JSONBIN_API_KEY = '$2a$10$RWXovJmFo.sJ0tRptHowp.2vluFhdI6ds1R4fILpL.Bq09q4SZ6FS';
    const JSONBIN_BIN_ID = '689cb5b0ae596e708fc94426';
    const SIGNALING_SERVER = `https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}`;

    const users = [
      { name: "Miguel", avatar: "avatar-0.webp", emoji: "🦔" },
      { name: "Anastasiia", avatar: "avatar-6.webp", emoji: "🐿️" },
      { name: "Mariana", avatar: "avatar-5.webp", emoji: "🦜" }
    ];

    let myUuid = null;
    let localStream = null;
    const peers = new Map();
    let isPolling = false;

    const iceServers = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    };

    // =========================================================================
    // INITIALIZATION
    // =========================================================================
    window.addEventListener('load', async () => {
      try {
        const activePeers = await fetchActivePeers();
        showUserSelection(users, activePeers);
      } catch (error) {
        console.log('Starting in offline mode');
        showUserSelection(users, []);
      }
    });

    async function fetchActivePeers() {
      try {
        const resp = await fetch(SIGNALING_SERVER + '/latest', {
          method: 'GET',
          headers: {
            'X-Master-Key': JSONBIN_API_KEY,
            'Content-Type': 'application/json'
          }
        });
        if (!resp.ok) {
          throw new Error(`Failed to fetch: ${resp.status}`);
        }
        const data = await resp.json();
        const record = data.record || {};
        const now = Date.now();
        const activePeers = [];
        for (const [peer, timestamp] of Object.entries(record.peers || {})) {
          if (now - timestamp < 30000) {
            activePeers.push(peer);
          }
        }
        return activePeers;
      } catch (error) {
        console.log('Using local-only mode:', error.message);
        return [];
      }
    }

    function showUserSelection(allUsers, takenList) {
      const userSelectionDiv = document.getElementById('userSelection');
      userSelectionDiv.innerHTML = '';

      allUsers.forEach(u => {
        const wrapper = document.createElement('div');
        wrapper.className = 'avatar-option';
        
        if (takenList.includes(u.name)) {
          wrapper.classList.add('disabled');
        }

        const img = document.createElement('img');
        img.src = u.avatar;
        img.alt = u.name;
        img.className = 'avatar-image';

        const label = document.createElement('div');
        label.className = 'avatar-name';
        label.textContent = `${u.emoji} ${u.name}`;

        wrapper.onclick = () => {
          if (wrapper.classList.contains('disabled')) return;
          
          document.querySelectorAll('.avatar-option').forEach(el => 
            el.classList.remove('avatar-selected')
          );
          wrapper.classList.add('avatar-selected');
          
          myUuid = u.name;
          document.getElementById('errorMessage').textContent = '';
          document.getElementById('joinButton').classList.remove('hidden');
        };

        wrapper.appendChild(img);
        wrapper.appendChild(label);
        userSelectionDiv.appendChild(wrapper);
      });
    }

    // =========================================================================
    // JOIN CALL
    // =========================================================================
    document.getElementById('joinButton').onclick = async function() {
      if (!myUuid) {
        document.getElementById('errorMessage').textContent = 'Please select an avatar!';
        return;
      }

      this.disabled = true;
      document.getElementById('errorMessage').textContent = '';

      try {
        // Get camera/mic
        localStream = await navigator.mediaDevices.getUserMedia({ 
          video: true, 
          audio: true 
        });

        // Register with signaling
        await registerPeer(myUuid);

        // Switch to video view
        document.querySelector('.container').style.display = 'none';
        
        const videoGrid = document.getElementById('videoGrid');
        videoGrid.style.display = 'grid';
        videoGrid.style.gridTemplateColumns = '1fr';

        // Add local video
        createVideoContainer(myUuid, localStream, true);

        // Start polling for peers
        isPolling = true;
        pollLoop();

      } catch (err) {
        this.disabled = false;
        document.getElementById('errorMessage').textContent = 
          'Error: ' + err.message;
      }
    };

    async function registerPeer(uuid) {
      try {
        const getResp = await fetch(SIGNALING_SERVER + '/latest', {
          headers: { 'X-Master-Key': JSONBIN_API_KEY }
        });
        const data = await getResp.json();
        const record = data.record || { peers: {}, messages: {} };
        
        record.peers = record.peers || {};
        record.peers[uuid] = Date.now();
        record.messages = record.messages || {};
        record.messages[uuid] = [];
        
        const updateResp = await fetch(SIGNALING_SERVER, {
          method: 'PUT',
          headers: {
            'X-Master-Key': JSONBIN_API_KEY,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(record)
        });
        
        if (!updateResp.ok) {
          throw new Error(`Registration failed: ${updateResp.status}`);
        }
        console.log('Registered with signaling server');
        return { uuid, registered: true };
      } catch (error) {
        console.log('Registration error - continuing in local mode');
        return { uuid, registered: false };
      }
    }

    async function pollLoop() {
      if (!isPolling) return;

      try {
        const activePeers = await fetchActivePeers();
        
        // Create connections for new peers
        for (const peerUuid of activePeers) {
          if (peerUuid === myUuid) continue;
          if (myUuid < peerUuid && !peers.has(peerUuid)) {
            await createPeerConnection(peerUuid, true);
          }
        }

        // Poll for messages
        const messages = await pollMessages();
        for (const msg of messages) {
          await handleSignalMessage(msg);
        }
      } catch (err) {
        console.error('Polling error:', err);
      }

      setTimeout(pollLoop, 2000);
    }

    async function pollMessages() {
      try {
        const resp = await fetch(SIGNALING_SERVER + '/latest', {
          headers: { 'X-Master-Key': JSONBIN_API_KEY }
        });
        if (!resp.ok) {
          throw new Error(`Poll failed: ${resp.status}`);
        }
        const data = await resp.json();
        const record = data.record || { messages: {} };
        const myMessages = record.messages?.[myUuid] || [];
        
        if (myMessages.length > 0) {
          record.messages[myUuid] = [];
          await fetch(SIGNALING_SERVER, {
            method: 'PUT',
            headers: {
              'X-Master-Key': JSONBIN_API_KEY,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(record)
          });
        }
        return myMessages;
      } catch (error) {
        return [];
      }
    }

    async function sendToPeer(targetUuid, type, data) {
      try {
        const getResp = await fetch(SIGNALING_SERVER + '/latest', {
          headers: { 'X-Master-Key': JSONBIN_API_KEY }
        });
        const result = await getResp.json();
        const record = result.record || { messages: {} };
        
        record.messages = record.messages || {};
        record.messages[targetUuid] = record.messages[targetUuid] || [];
        record.messages[targetUuid].push({ type, data, from: myUuid });
        
        await fetch(SIGNALING_SERVER, {
          method: 'PUT',
          headers: {
            'X-Master-Key': JSONBIN_API_KEY,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(record)
        });
      } catch (err) {
        console.error('Send error:', err);
      }
    }

    // =========================================================================
    // WEBRTC
    // =========================================================================
    async function createPeerConnection(targetUuid, createOffer) {
      if (peers.has(targetUuid)) return peers.get(targetUuid);

      const pc = new RTCPeerConnection(iceServers);
      peers.set(targetUuid, pc);

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          sendToPeer(targetUuid, 'ice-candidate', event.candidate);
        }
      };

      pc.ontrack = (event) => {
        createVideoContainer(targetUuid, event.streams[0], false);
      };

      if (localStream) {
        localStream.getTracks().forEach(track => {
          pc.addTrack(track, localStream);
        });
      }

      if (createOffer) {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await sendToPeer(targetUuid, 'offer', offer);
      }

      return pc;
    }

    async function handleSignalMessage(msg) {
      const { type, data, from } = msg;

      try {
        switch (type) {
          case 'offer': {
            const pc = await createPeerConnection(from, false);
            await pc.setRemoteDescription(new RTCSessionDescription(data));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            await sendToPeer(from, 'answer', answer);
            break;
          }
          case 'answer': {
            const pc = peers.get(from);
            if (pc) {
              await pc.setRemoteDescription(new RTCSessionDescription(data));
            }
            break;
          }
          case 'ice-candidate': {
            const pc = peers.get(from);
            if (pc) {
              await pc.addIceCandidate(new RTCIceCandidate(data));
            }
            break;
          }
        }
      } catch (err) {
        console.error('Error handling signal:', err);
      }
    }

    function createVideoContainer(uuid, stream, isLocal) {
      let container = document.getElementById(`video-${uuid}`);
      
      if (!container) {
        container = document.createElement('div');
        container.className = 'videoContainer';
        container.id = `video-${uuid}`;

        const video = document.createElement('video');
        video.autoplay = true;
        video.playsInline = true;
        if (isLocal) video.muted = true;

        const label = document.createElement('div');
        label.className = 'peerId';
        const user = users.find(u => u.name === uuid);
        label.textContent = user ? `${user.emoji} ${uuid}` : uuid;
        if (isLocal) label.textContent += ' (You)';

        container.appendChild(video);
        container.appendChild(label);
        document.getElementById('videoGrid').appendChild(container);

        adjustGridLayout();
      }

      const video = container.querySelector('video');
      if (video.srcObject !== stream) {
        video.srcObject = stream;
      }
    }

    function adjustGridLayout() {
      const grid = document.getElementById('videoGrid');
      const count = grid.querySelectorAll('.videoContainer').length;
      
      if (count <= 1) {
        grid.style.gridTemplateColumns = '1fr';
      } else if (count === 2) {
        grid.style.gridTemplateColumns = '1fr 1fr';
      } else if (count <= 4) {
        grid.style.gridTemplateColumns = '1fr 1fr';
      } else {
        grid.style.gridTemplateColumns = '1fr 1fr 1fr';
      }
    }

    // Cleanup on exit
    window.addEventListener('beforeunload', async () => {
      isPolling = false;
      if (myUuid) {
        try {
          const getResp = await fetch(SIGNALING_SERVER + '/latest', {
            headers: { 'X-Master-Key': JSONBIN_API_KEY }
          });
          const data = await getResp.json();
          const record = data.record || {};
          if (record.peers && record.peers[myUuid]) {
            delete record.peers[myUuid];
            delete record.messages[myUuid];
            await fetch(SIGNALING_SERVER, {
              method: 'PUT',
              headers: {
                'X-Master-Key': JSONBIN_API_KEY,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(record)
            });
          }
        } catch (err) {
          console.error('Cleanup error:', err);
        }
      }
      peers.forEach(pc => pc.close());
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
      }
    });
  </script>
</body>
</html>