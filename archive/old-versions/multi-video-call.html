<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Multi-User Video Call (Server-Relayed)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0f0f23;
      color: #ccc;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1600px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      margin-bottom: 10px;
      color: #00ff41;
      font-size: 2em;
    }

    .subtitle {
      text-align: center;
      color: #888;
      margin-bottom: 20px;
      font-size: 14px;
    }

    .status-bar {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
      padding: 15px;
      background: rgba(0,255,65,0.1);
      border: 1px solid #00ff41;
      border-radius: 5px;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ff4444;
    }

    .indicator.active {
      background: #00ff41;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(0,255,65,0.4); }
      70% { box-shadow: 0 0 0 10px rgba(0,255,65,0); }
      100% { box-shadow: 0 0 0 0 rgba(0,255,65,0); }
    }

    .controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-bottom: 30px;
    }

    button {
      padding: 12px 30px;
      font-size: 16px;
      border: 1px solid #00ff41;
      border-radius: 5px;
      background: transparent;
      color: #00ff41;
      cursor: pointer;
      transition: all 0.3s;
    }

    button:hover:not(:disabled) {
      background: #00ff41;
      color: #0f0f23;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    button.active {
      background: #00ff41;
      color: #0f0f23;
    }

    .videos-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .video-container {
      position: relative;
      background: #1a1a2e;
      border-radius: 10px;
      overflow: hidden;
      aspect-ratio: 4/3;
    }

    .video-label {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.8);
      padding: 5px 15px;
      border-radius: 5px;
      z-index: 10;
      font-size: 12px;
      color: #00ff41;
    }

    video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      background: #000;
    }

    .local-video {
      border: 2px solid #00ff41;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      padding: 20px;
      background: rgba(255,255,255,0.05);
      border-radius: 10px;
      margin-top: 20px;
    }

    .stat {
      text-align: center;
    }

    .stat-value {
      font-size: 24px;
      color: #00ff41;
      font-weight: bold;
    }

    .stat-label {
      font-size: 12px;
      color: #888;
      margin-top: 5px;
    }

    .info {
      background: rgba(0,100,255,0.1);
      border: 1px solid #0064ff;
      border-radius: 5px;
      padding: 15px;
      margin-bottom: 20px;
      text-align: center;
    }

    .error {
      background: rgba(255,0,0,0.1);
      border: 1px solid #ff0000;
      color: #ff6b6b;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ðŸŽ¥ Multi-User Video Conference</h1>
    <p class="subtitle">All video streams through VPS server (like YouTube/Twitch)</p>
    
    <div class="status-bar">
      <div class="status-item">
        <div class="indicator" id="wsIndicator"></div>
        <span id="wsStatus">Disconnected</span>
      </div>
      <div class="status-item">
        <span>Room: Global (Auto-join)</span>
      </div>
      <div class="status-item">
        <span>Publishers: <span id="publisherCount">0</span></span>
      </div>
    </div>

    <div class="info" id="infoBox">
      Click "Start Broadcasting" to share your video. Everyone who joins automatically sees all broadcasters.
    </div>
    
    <div class="controls">
      <button id="broadcastBtn" onclick="toggleBroadcast()">Start Broadcasting</button>
      <button id="muteBtn" onclick="toggleMute()" disabled>Mute</button>
    </div>
    
    <div class="videos-grid" id="videosGrid">
      <!-- Videos will be added dynamically -->
    </div>
    
    <div class="stats">
      <div class="stat">
        <div class="stat-value" id="bitrate">0</div>
        <div class="stat-label">kbps</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="latency">0</div>
        <div class="stat-label">ms latency</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="fps">0</div>
        <div class="stat-label">FPS</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="resolution">-</div>
        <div class="stat-label">Resolution</div>
      </div>
    </div>
  </div>

  <script>
    const WS_URL = 'ws://194.87.103.57:3000/ws';
    const ICE_SERVERS = [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun1.l.google.com:19302' }
    ];
    
    let ws = null;
    let localStream = null;
    let clientId = null;
    let peerId = null;
    let isBroadcasting = false;
    let isMuted = false;
    
    // Store peer connections
    const peerConnections = new Map();
    const remoteStreams = new Map();
    
    // Connect to WebSocket server
    function connect() {
      console.log('Connecting to relay server...');
      ws = new WebSocket(WS_URL);
      
      ws.onopen = () => {
        console.log('Connected to relay server');
        updateConnectionStatus(true);
        
        // Join as viewer initially
        ws.send(JSON.stringify({ type: 'join-as-viewer' }));
      };
      
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);
        await handleSignaling(message);
      };
      
      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        showError('Connection error. Retrying...');
      };
      
      ws.onclose = () => {
        console.log('Disconnected from server');
        updateConnectionStatus(false);
        
        // Cleanup and reconnect
        cleanup();
        setTimeout(connect, 3000);
      };
    }
    
    async function handleSignaling(message) {
      console.log('Received:', message.type);
      
      switch (message.type) {
        case 'welcome':
          clientId = message.clientId;
          peerId = 'peer-' + clientId;
          console.log('My ID:', clientId);
          break;
          
        case 'existing-publishers':
        case 'current-publishers':
          // Connect to each existing publisher
          for (const publisherId of message.publishers) {
            await connectToPublisher(publisherId);
          }
          updatePublisherCount();
          break;
          
        case 'publisher-joined':
          // New publisher joined, connect to them
          await connectToPublisher(message.publisherId);
          updatePublisherCount();
          break;
          
        case 'publisher-left':
          // Publisher left, cleanup their connection
          disconnectFromPublisher(message.publisherId);
          updatePublisherCount();
          break;
          
        case 'offer-requested':
          // A viewer wants our stream, create offer for them
          if (isBroadcasting) {
            await createOfferForViewer(message.viewerId);
          }
          break;
          
        case 'offer':
          // Received offer from publisher
          await handleOffer(message.from, message.offer);
          break;
          
        case 'answer':
          // Received answer from viewer
          await handleAnswer(message.from, message.answer);
          break;
          
        case 'ice-candidate':
          // Received ICE candidate
          await handleIceCandidate(message.from, message.candidate);
          break;
      }
    }
    
    async function toggleBroadcast() {
      if (isBroadcasting) {
        stopBroadcasting();
      } else {
        await startBroadcasting();
      }
    }
    
    async function startBroadcasting() {
      try {
        // Get user media
        localStream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: 1280 },
            height: { ideal: 720 },
            frameRate: { ideal: 30 }
          },
          audio: true
        });
        
        // Add local video to grid
        addVideoToGrid('local', localStream, 'You (Broadcasting)');
        
        // Notify server we're publishing
        ws.send(JSON.stringify({
          type: 'join-as-publisher',
          peerId: peerId
        }));
        
        isBroadcasting = true;
        document.getElementById('broadcastBtn').textContent = 'Stop Broadcasting';
        document.getElementById('broadcastBtn').classList.add('active');
        document.getElementById('muteBtn').disabled = false;
        
        showInfo('Broadcasting started! Others will see your video automatically.');
        
        // Start monitoring stats
        startStatsMonitoring();
        
      } catch (error) {
        console.error('Error starting broadcast:', error);
        showError('Failed to access camera/microphone: ' + error.message);
      }
    }
    
    function stopBroadcasting() {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      
      // Remove local video
      removeVideoFromGrid('local');
      
      // Close all peer connections where we're the publisher
      peerConnections.forEach((pc, id) => {
        if (id.startsWith('viewer-')) {
          pc.close();
          peerConnections.delete(id);
        }
      });
      
      isBroadcasting = false;
      document.getElementById('broadcastBtn').textContent = 'Start Broadcasting';
      document.getElementById('broadcastBtn').classList.remove('active');
      document.getElementById('muteBtn').disabled = true;
      
      showInfo('Broadcasting stopped.');
    }
    
    async function connectToPublisher(publisherId) {
      console.log('Connecting to publisher:', publisherId);
      
      // Create peer connection for this publisher
      const pc = new RTCPeerConnection({
        iceServers: ICE_SERVERS
      });
      
      peerConnections.set(publisherId, pc);
      
      // Handle incoming stream
      pc.ontrack = (event) => {
        console.log('Received track from', publisherId);
        if (event.streams && event.streams[0]) {
          remoteStreams.set(publisherId, event.streams[0]);
          addVideoToGrid(publisherId, event.streams[0], `User ${publisherId.substr(-6)}`);
        }
      };
      
      // Handle ICE candidates
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          ws.send(JSON.stringify({
            type: 'ice-candidate',
            to: publisherId,
            candidate: event.candidate
          }));
        }
      };
      
      // Request offer from publisher
      ws.send(JSON.stringify({
        type: 'request-offer',
        publisherId: publisherId
      }));
    }
    
    async function createOfferForViewer(viewerId) {
      console.log('Creating offer for viewer:', viewerId);
      
      const pc = new RTCPeerConnection({
        iceServers: ICE_SERVERS
      });
      
      peerConnections.set('viewer-' + viewerId, pc);
      
      // Add local stream tracks
      if (localStream) {
        localStream.getTracks().forEach(track => {
          pc.addTrack(track, localStream);
        });
      }
      
      // Handle ICE candidates
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          ws.send(JSON.stringify({
            type: 'ice-candidate',
            to: viewerId,
            candidate: event.candidate
          }));
        }
      };
      
      // Create and send offer
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      
      ws.send(JSON.stringify({
        type: 'offer',
        to: viewerId,
        offer: offer
      }));
    }
    
    async function handleOffer(from, offer) {
      console.log('Handling offer from:', from);
      
      let pc = peerConnections.get(from);
      if (!pc) {
        // Create new peer connection if doesn't exist
        pc = new RTCPeerConnection({
          iceServers: ICE_SERVERS
        });
        peerConnections.set(from, pc);
        
        pc.ontrack = (event) => {
          console.log('Received track from', from);
          if (event.streams && event.streams[0]) {
            remoteStreams.set(from, event.streams[0]);
            addVideoToGrid(from, event.streams[0], `User ${from.substr(-6)}`);
          }
        };
        
        pc.onicecandidate = (event) => {
          if (event.candidate) {
            ws.send(JSON.stringify({
              type: 'ice-candidate',
              to: from,
              candidate: event.candidate
            }));
          }
        };
      }
      
      await pc.setRemoteDescription(new RTCSessionDescription(offer));
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      
      ws.send(JSON.stringify({
        type: 'answer',
        to: from,
        answer: answer
      }));
    }
    
    async function handleAnswer(from, answer) {
      console.log('Handling answer from:', from);
      
      const pc = peerConnections.get('viewer-' + from);
      if (pc) {
        await pc.setRemoteDescription(new RTCSessionDescription(answer));
      }
    }
    
    async function handleIceCandidate(from, candidate) {
      const pc = peerConnections.get(from) || peerConnections.get('viewer-' + from);
      if (pc && candidate) {
        try {
          await pc.addIceCandidate(new RTCIceCandidate(candidate));
        } catch (e) {
          console.error('Error adding ICE candidate:', e);
        }
      }
    }
    
    function disconnectFromPublisher(publisherId) {
      const pc = peerConnections.get(publisherId);
      if (pc) {
        pc.close();
        peerConnections.delete(publisherId);
      }
      
      remoteStreams.delete(publisherId);
      removeVideoFromGrid(publisherId);
    }
    
    function addVideoToGrid(id, stream, label) {
      // Remove existing if any
      removeVideoFromGrid(id);
      
      const container = document.createElement('div');
      container.className = 'video-container';
      container.id = 'video-container-' + id;
      
      if (id === 'local') {
        container.classList.add('local-video');
      }
      
      const labelDiv = document.createElement('div');
      labelDiv.className = 'video-label';
      labelDiv.textContent = label;
      
      const video = document.createElement('video');
      video.autoplay = true;
      video.playsinline = true;
      if (id === 'local') {
        video.muted = true;
      }
      video.srcObject = stream;
      
      container.appendChild(labelDiv);
      container.appendChild(video);
      
      document.getElementById('videosGrid').appendChild(container);
      
      // Update resolution display
      if (id === 'local') {
        video.onloadedmetadata = () => {
          document.getElementById('resolution').textContent = 
            `${video.videoWidth}x${video.videoHeight}`;
        };
      }
    }
    
    function removeVideoFromGrid(id) {
      const container = document.getElementById('video-container-' + id);
      if (container) {
        container.remove();
      }
    }
    
    function toggleMute() {
      if (localStream) {
        const audioTrack = localStream.getAudioTracks()[0];
        if (audioTrack) {
          audioTrack.enabled = !audioTrack.enabled;
          isMuted = !audioTrack.enabled;
          document.getElementById('muteBtn').textContent = isMuted ? 'Unmute' : 'Mute';
        }
      }
    }
    
    function updateConnectionStatus(connected) {
      const indicator = document.getElementById('wsIndicator');
      const status = document.getElementById('wsStatus');
      
      if (connected) {
        indicator.classList.add('active');
        status.textContent = 'Connected';
      } else {
        indicator.classList.remove('active');
        status.textContent = 'Disconnected';
      }
    }
    
    function updatePublisherCount() {
      const count = remoteStreams.size;
      document.getElementById('publisherCount').textContent = count;
    }
    
    function showInfo(message) {
      const infoBox = document.getElementById('infoBox');
      infoBox.textContent = message;
      infoBox.classList.remove('error');
    }
    
    function showError(message) {
      const infoBox = document.getElementById('infoBox');
      infoBox.textContent = message;
      infoBox.classList.add('error');
    }
    
    function cleanup() {
      // Close all peer connections
      peerConnections.forEach(pc => pc.close());
      peerConnections.clear();
      
      // Clear remote streams
      remoteStreams.clear();
      
      // Clear video grid except local
      const grid = document.getElementById('videosGrid');
      const videos = grid.querySelectorAll('.video-container:not(.local-video)');
      videos.forEach(v => v.remove());
    }
    
    async function startStatsMonitoring() {
      setInterval(async () => {
        if (!isBroadcasting) return;
        
        let totalBitrate = 0;
        let totalFps = 0;
        let count = 0;
        
        for (const [id, pc] of peerConnections) {
          if (id.startsWith('viewer-')) {
            const stats = await pc.getStats();
            stats.forEach(report => {
              if (report.type === 'outbound-rtp' && report.kind === 'video') {
                const bitrate = (report.bytesSent * 8) / 1000; // kbps
                totalBitrate += bitrate;
                if (report.framesPerSecond) {
                  totalFps += report.framesPerSecond;
                  count++;
                }
              }
            });
          }
        }
        
        document.getElementById('bitrate').textContent = Math.round(totalBitrate);
        if (count > 0) {
          document.getElementById('fps').textContent = Math.round(totalFps / count);
        }
      }, 1000);
    }
    
    // Start on load
    window.addEventListener('load', () => {
      connect();
    });
  </script>
</body>
</html>