<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Forest Friends Video Call - Progressive Loading</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      min-height: 100vh;
      overflow: hidden;
      position: relative;
      background: #87CEEB;
    }

    /* Loading states */
    .background-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    .background-image {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      min-width: 100%;
      min-height: 100%;
      width: auto;
      height: auto;
      object-fit: cover;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
    }

    .background-image.loaded {
      opacity: 1;
    }

    .background-image.animated {
      animation: slowZoom 60s ease-in-out infinite alternate;
    }

    /* Placeholder gradient while loading */
    .loading-gradient {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #87CEEB 0%, #98D98E 50%, #90EE90 100%);
      opacity: 1;
      transition: opacity 1s ease-out;
    }

    .loading-gradient.hidden {
      opacity: 0;
      pointer-events: none;
    }

    /* Dynamic keyframes injected by JS */

    /* Main content */
    .container {
      position: relative;
      z-index: 10;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }


    .avatar-grid {
      display: flex;
      justify-content: center;
      gap: clamp(30px, 5vw, 60px);
      flex-wrap: wrap;
    }

    .avatar-option {
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
    }

    .avatar-option:hover {
      transform: translateY(-5px);
    }

    .avatar-image {
      width: clamp(100px, 15vw, 140px);
      height: clamp(100px, 15vw, 140px);
      border-radius: 50%;
      object-fit: cover;
      border: 4px solid transparent;
      transition: all 0.3s ease;
      box-shadow: 0 5px 20px rgba(0,0,0,0.1);
    }

    .avatar-option:hover .avatar-image {
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
      border-color: #90EE90;
    }

    .avatar-selected .avatar-image {
      border-color: #4a7c20 !important;
      box-shadow: 0 0 0 3px rgba(74, 124, 32, 0.2);
    }

    .avatar-option.disabled {
      opacity: 0.4;
      pointer-events: none;
    }


    .hidden {
      display: none !important;
    }

    .error-message {
      color: #d9534f;
      text-align: center;
      margin-top: 15px;
      font-weight: 500;
    }


    /* Video grid */
    #videoGrid {
      display: none;
      width: 100%;
      height: 100vh;
      background: rgba(0,0,0,0.8);
      padding: 20px;
      grid-gap: 15px;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 100;
    }

    .videoContainer {
      position: relative;
      background: #000;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }

    .videoContainer video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .peerId {
      position: absolute;
      bottom: 15px;
      left: 15px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 8px 15px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 500;
    }
  </style>
</head>
<body>
  <!-- Background layers -->
  <div class="background-container">
    <div class="loading-gradient" id="loadingGradient"></div>
    <img class="background-image" id="backgroundLow" alt="" />
    <img class="background-image" id="backgroundHigh" alt="" />
  </div>


  <!-- Main content -->
  <div class="container">
    <div id="userSelection" class="avatar-grid"></div>
    <div id="errorMessage" class="error-message"></div>
  </div>

  <!-- Video grid (hidden until joined) -->
  <div id="videoGrid"></div>

  <script>
    // =========================================================================
    // PROGRESSIVE IMAGE LOADING SYSTEM
    // =========================================================================
    
    // Device detection
    const DeviceProfile = {
      isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
      isLowEnd: navigator.hardwareConcurrency <= 2,
      connectionSpeed: navigator.connection?.effectiveType || '4g',
      screenWidth: window.innerWidth,
      screenHeight: window.innerHeight,
      deviceMemory: navigator.deviceMemory || 4,
      
      getProfile() {
        if (this.isMobile || this.deviceMemory < 4 || this.isLowEnd) {
          return 'mobile';
        } else if (this.deviceMemory >= 8 && this.screenWidth > 1920) {
          return 'desktop-high';
        } else {
          return 'desktop';
        }
      }
    };

    // Image configuration
    const backgroundImages = [
      {
        name: "Line-000002.png",
        url: "assets/trees/Line-000002.png",
        zoomedUrl: "assets/trees/zoomed/Line-000002-zoomed.jpg", 
        trunkCenter: { x: 0.367, y: 0.372 }
      },
      {
        name: "Line-000003.png",
        url: "assets/trees/Line-000003.png",
        zoomedUrl: "assets/trees/zoomed/Line-000003-zoomed.jpg",
        trunkCenter: { x: 0.570, y: 0.402 }
      },
      {
        name: "Line-000004.png",
        url: "assets/trees/Line-000004.png",
        zoomedUrl: "assets/trees/zoomed/Line-000004-zoomed.jpg",
        trunkCenter: { x: 0.633, y: 0.441 }
      },
      {
        name: "Line-000005.png",
        url: "assets/trees/Line-000005.png",
        zoomedUrl: "assets/trees/zoomed/Line-000005-zoomed.jpg",
        trunkCenter: { x: 0.249, y: 0.620 }
      },
      {
        name: "Line-000006.png",
        url: "assets/trees/Line-000006.png",
        zoomedUrl: "assets/trees/zoomed/Line-000006-zoomed.jpg",
        trunkCenter: { x: 0.699, y: 0.855 }
      },
      {
        name: "Line-000007.png",
        url: "assets/trees/Line-000007.png",
        zoomedUrl: "assets/trees/zoomed/Line-000007-zoomed.jpg",
        trunkCenter: { x: 0.281, y: 0.627 }
      },
      {
        name: "Line-000008.png",
        url: "assets/trees/Line-000008.png",
        zoomedUrl: "assets/trees/zoomed/Line-000008-zoomed.jpg",
        trunkCenter: { x: 0.261, y: 0.653 }
      },
      {
        name: "Line-000009.png",
        url: "assets/trees/Line-000009.png",
        zoomedUrl: "assets/trees/zoomed/Line-000009-zoomed.jpg",
        trunkCenter: { x: 0.312, y: 0.665 }
      },
      {
        name: "Line-000010.png",
        url: "assets/trees/Line-000010.png",
        zoomedUrl: "assets/trees/zoomed/Line-000010-zoomed.jpg",
        trunkCenter: { x: 0.352, y: 0.646 }
      },
      {
        name: "Line-000011.png",
        url: "assets/trees/Line-000011.png",
        zoomedUrl: "assets/trees/zoomed/Line-000011-zoomed.jpg",
        trunkCenter: { x: 0.351, y: 0.698 }
      },
      {
        name: "Line-000012.png",
        url: "assets/trees/Line-000012.png",
        zoomedUrl: "assets/trees/zoomed/Line-000012-zoomed.jpg",
        trunkCenter: { x: 0.321, y: 0.631 }
      },
      {
        name: "Line-000013.png",
        url: "assets/trees/Line-000013.png",
        zoomedUrl: "assets/trees/zoomed/Line-000013-zoomed.jpg",
        trunkCenter: { x: 0.315, y: 0.566 }
      }
    ];

    // Cache management
    class ImageCache {
      constructor() {
        this.cache = new Map();
        this.maxSize = DeviceProfile.isMobile ? 2 : 5; // Max images to keep in memory
      }

      async preloadImage(url) {
        if (this.cache.has(url)) {
          return this.cache.get(url);
        }

        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
            // Manage cache size
            if (this.cache.size >= this.maxSize) {
              const firstKey = this.cache.keys().next().value;
              this.cache.delete(firstKey);
            }
            this.cache.set(url, img);
            resolve(img);
          };
          img.onerror = reject;
          img.src = url;
        });
      }

      has(url) {
        return this.cache.has(url);
      }
    }

    const imageCache = new ImageCache();

    // Progressive loader
    class ProgressiveImageLoader {
      constructor() {
        this.profile = DeviceProfile.getProfile();
        this.currentImage = null;
      }

      async loadBackgroundImage() {
        const urlParams = new URLSearchParams(window.location.search);
        const zoomSpeed = urlParams.get('zoom') || '60';
        const imageIndex = urlParams.get('img');
        
        // Select image based on device profile
        let selectedImage;
        if (this.profile === 'mobile') {
          // Mobile: always use the same image for consistency
          selectedImage = backgroundImages[5]; // Line-000006 as default
        } else {
          // Desktop: random or specified
          if (imageIndex !== null && imageIndex >= 0 && imageIndex < backgroundImages.length) {
            selectedImage = backgroundImages[imageIndex];
          } else {
            selectedImage = backgroundImages[Math.floor(Math.random() * backgroundImages.length)];
          }
        }

        this.currentImage = selectedImage;
        
        const loadingGradient = document.getElementById('loadingGradient');
        const bgLow = document.getElementById('backgroundLow');
        const bgHigh = document.getElementById('backgroundHigh');

        try {
          if (this.profile === 'mobile') {
            // Mobile: Load zoomed version only
            const zoomedImg = await imageCache.preloadImage(selectedImage.zoomedUrl);
            bgLow.src = zoomedImg.src;
            bgLow.classList.add('loaded');
            loadingGradient.classList.add('hidden');
            
            // No animation on mobile - already zoomed
            
          } else if (this.profile === 'desktop') {
            // Desktop: Progressive loading
            // 1. Try to load zoomed version first (faster)
            try {
              const zoomedImg = await imageCache.preloadImage(selectedImage.zoomedUrl);
              bgLow.src = zoomedImg.src;
              bgLow.classList.add('loaded');
              loadingGradient.classList.add('hidden');
            } catch (e) {
              console.log('Zoomed version not available, loading full');
            }
            
            // 2. Load full version in background
            const fullImg = await imageCache.preloadImage(selectedImage.url);
            bgHigh.src = fullImg.src;
            bgHigh.classList.add('loaded');
            
            // 3. Hide low quality once high is loaded
            setTimeout(() => {
              bgLow.style.display = 'none';
              // Enable zoom animation
              this.setupZoomAnimation(selectedImage, zoomSpeed);
              bgHigh.classList.add('animated');
            }, 500);
            
            
            // 4. Preload next image if desktop-high
            if (this.profile === 'desktop-high') {
              this.preloadNext();
            }
            
          } else {
            // Desktop-high: Load full immediately + preload others
            const fullImg = await imageCache.preloadImage(selectedImage.url);
            bgHigh.src = fullImg.src;
            bgHigh.classList.add('loaded');
            loadingGradient.classList.add('hidden');
            
            this.setupZoomAnimation(selectedImage, zoomSpeed);
            bgHigh.classList.add('animated');
            
            
            // Preload multiple images
            this.preloadNext(3);
          }
          
        } catch (error) {
          console.error('Failed to load image:', error);
          // Keep gradient as fallback
        }

      }

      setupZoomAnimation(image, duration) {
        const offsetX = (image.trunkCenter.x - 0.5) * 200;
        const offsetY = (image.trunkCenter.y - 0.5) * 200;
        
        const style = document.createElement('style');
        style.textContent = `
          @keyframes slowZoom {
            0% {
              transform: translate(-50%, -50%) scale(1.0);
            }
            100% {
              transform: translate(calc(-50% + ${offsetX}px), calc(-50% + ${offsetY}px)) scale(1.5);
            }
          }
          .animated {
            animation-duration: ${duration}s !important;
          }
        `;
        document.head.appendChild(style);
      }

      async preloadNext(count = 1) {
        // Preload next random images in background
        const indices = new Set();
        while (indices.size < count) {
          indices.add(Math.floor(Math.random() * backgroundImages.length));
        }
        
        for (const idx of indices) {
          if (backgroundImages[idx] !== this.currentImage) {
            try {
              await imageCache.preloadImage(backgroundImages[idx].url);
                  } catch (e) {
              // Silent fail for preloads
            }
          }
        }
      }
    }

    // =========================================================================
    // VIDEO CALL APPLICATION
    // =========================================================================
    const JSONBIN_API_KEY = '$2a$10$RWXovJmFo.sJ0tRptHowp.2vluFhdI6ds1R4fILpL.Bq09q4SZ6FS';
    const JSONBIN_BIN_ID = '689cb5b0ae596e708fc94426';
    
    // Use CORS proxy only for GitHub Pages, direct access for local testing
    const isGitHubPages = window.location.hostname === 'miguelemosreverte.github.io';
    const SIGNALING_SERVER = isGitHubPages 
      ? `https://corsproxy.io/?https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}`
      : `https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}`;

    const users = [
      { name: "Miguel", avatar: "avatar-0.webp", emoji: "ðŸ¦”" },
      { name: "Anastasiia", avatar: "avatar-6.webp", emoji: "ðŸ¿ï¸" },
      { name: "Mariana", avatar: "avatar-5.webp", emoji: "ðŸ¦œ" }
    ];

    let myUuid = null;
    let localStream = null;
    const peers = new Map();
    let isPolling = false;
    let lastKnownPeers = [];
    const processedMessages = new Set();
    const iceCandidateQueue = new Map(); // Buffer ICE candidates

    const iceServers = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    };

    // Initialize
    window.addEventListener('load', async () => {
      // Start loading background
      const loader = new ProgressiveImageLoader();
      await loader.loadBackgroundImage();
      
      // Load user selection
      try {
        const activePeers = await fetchActivePeers();
        showUserSelection(users, activePeers);
      } catch (error) {
        console.log('Starting in offline mode');
        showUserSelection(users, []);
      }
    });

    async function fetchActivePeers() {
      try {
        const resp = await fetch(SIGNALING_SERVER + '/latest', {
          method: 'GET',
          mode: 'cors',
          headers: {
            'X-Master-Key': JSONBIN_API_KEY
          }
        });
        if (!resp.ok) {
          throw new Error(`Failed to fetch: ${resp.status}`);
        }
        const data = await resp.json();
        const record = data.record || {};
        const now = Date.now();
        const activePeers = [];
        // Only log peers if there's a change
        const peerCount = Object.keys(record.peers || {}).length;
        if (peerCount > 0) {
          for (const [peer, timestamp] of Object.entries(record.peers || {})) {
            if (now - timestamp < 30000) {
              activePeers.push(peer);
            }
          }
        }
        return activePeers;
      } catch (error) {
        console.log('Using local-only mode:', error.message);
        return [];
      }
    }

    function showUserSelection(allUsers, takenList) {
      const userSelectionDiv = document.getElementById('userSelection');
      userSelectionDiv.innerHTML = '';

      allUsers.forEach(u => {
        const wrapper = document.createElement('div');
        wrapper.className = 'avatar-option';
        
        if (takenList.includes(u.name)) {
          wrapper.classList.add('disabled');
        }

        const img = document.createElement('img');
        img.src = u.avatar;
        img.alt = u.name;
        img.className = 'avatar-image';

        wrapper.onclick = () => {
          if (wrapper.classList.contains('disabled')) return;
          
          document.querySelectorAll('.avatar-option').forEach(el => 
            el.classList.remove('avatar-selected')
          );
          wrapper.classList.add('avatar-selected');
          
          myUuid = u.name;
          document.getElementById('errorMessage').textContent = '';
          
          // Immediately join the call
          setTimeout(() => joinCall(), 100);
        };

        wrapper.appendChild(img);
        userSelectionDiv.appendChild(wrapper);
      });
    }

    // =========================================================================
    // JOIN CALL
    // =========================================================================
    async function joinCall() {
      if (!myUuid) {
        document.getElementById('errorMessage').textContent = 'Please select an avatar!';
        return;
      }

      document.getElementById('errorMessage').textContent = '';

      try {
        // Get camera/mic
        localStream = await navigator.mediaDevices.getUserMedia({ 
          video: true, 
          audio: true 
        });

        // Register with signaling
        const registration = await registerPeer(myUuid);

        // Switch to video view
        document.querySelector('.container').style.display = 'none';
        
        const videoGrid = document.getElementById('videoGrid');
        videoGrid.style.display = 'grid';
        videoGrid.style.gridTemplateColumns = '1fr';

        // Add local video
        createVideoContainer(myUuid, localStream, true);

        // Start polling for peers
        isPolling = true;
        
        // Connect to existing peers in the room
        if (registration.existingPeers && registration.existingPeers.length > 0) {
          console.log('Found existing peers in room:', registration.existingPeers);
          for (const peer of registration.existingPeers) {
            const shouldInitiate = myUuid.localeCompare(peer) < 0;
            console.log(`Checking connection to ${peer}: myUuid="${myUuid}" vs peer="${peer}", shouldInitiate=${shouldInitiate}`);
            if (shouldInitiate) {
              console.log(`Initiating connection to existing peer: ${peer}`);
              await createPeerConnection(peer, true);
            } else {
              console.log(`Waiting for ${peer} to initiate connection to us`);
            }
          }
        }
        
        pollLoop();
        
        // Start heartbeat to keep registration alive
        setInterval(() => {
          if (myUuid && isPolling) {
            registerPeer(myUuid);
          }
        }, 20000); // Update every 20 seconds
        
        // Ping connected peers periodically
        setInterval(async () => {
          if (myUuid && isPolling) {
            for (const [peerUuid, pc] of peers) {
              if (pc.connectionState === 'connected') {
                await sendToPeer(peerUuid, 'ping', { timestamp: Date.now() });
              }
            }
          }
        }, 120000); // Ping every 2 minutes

      } catch (err) {
        document.getElementById('errorMessage').textContent = 
          'Error: ' + err.message;
      }
    }

    async function registerPeer(uuid) {
      try {
        const getResp = await fetch(SIGNALING_SERVER + '/latest', {
          headers: { 'X-Master-Key': JSONBIN_API_KEY }
        });
        const data = await getResp.json();
        const record = data.record || { peers: {}, messages: {} };
        
        record.peers = record.peers || {};
        record.messages = record.messages || {};
        
        const now = Date.now();
        const wasNewPeer = !record.peers[uuid];
        
        // Clean up stale peers (older than 60 seconds)
        const stalePeers = [];
        for (const [peer, timestamp] of Object.entries(record.peers)) {
          if (now - timestamp > 60000 && peer !== uuid) {
            stalePeers.push(peer);
            delete record.peers[peer];
            delete record.messages[peer];
          }
        }
        
        if (stalePeers.length > 0) {
          console.log('Cleaned up stale peers:', stalePeers);
        }
        
        // Update our timestamp
        record.peers[uuid] = now;
        
        // Initialize our message queue if needed
        if (!record.messages[uuid]) {
          record.messages[uuid] = [];
        }
        
        // If we're a new peer, send enter event to all existing peers
        if (wasNewPeer) {
          const existingPeers = Object.keys(record.peers).filter(p => p !== uuid);
          for (const peer of existingPeers) {
            record.messages[peer] = record.messages[peer] || [];
            record.messages[peer].push({
              type: 'peer-entered',
              from: uuid,
              timestamp: now
            });
          }
          console.log('Sending enter event to existing peers:', existingPeers);
        }
        
        const updateResp = await fetch(SIGNALING_SERVER, {
          method: 'PUT',
          headers: {
            'X-Master-Key': JSONBIN_API_KEY,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(record)
        });
        
        if (!updateResp.ok) {
          throw new Error(`Registration failed: ${updateResp.status}`);
        }
        console.log('Registered with signaling server as:', uuid);
        console.log('Room state after registration:', record.peers);
        return { uuid, registered: true, existingPeers: Object.keys(record.peers).filter(p => p !== uuid) };
      } catch (error) {
        console.log('Registration error - continuing in local mode');
        return { uuid, registered: false };
      }
    }

    async function pollLoop() {
      if (!isPolling) return;

      try {
        const activePeers = await fetchActivePeers();
        
        // Only log if peers changed
        const peersChanged = JSON.stringify(activePeers.sort()) !== JSON.stringify(lastKnownPeers.sort());
        if (peersChanged) {
          console.log('Active peers in room:', activePeers);
          lastKnownPeers = [...activePeers];
        }
        
        // Create connections for new peers
        for (const peerUuid of activePeers) {
          if (peerUuid === myUuid) continue;
          
          if (!peers.has(peerUuid)) {
            // Only the peer with the lower UUID initiates the connection
            // This prevents duplicate connections
            const shouldInitiate = myUuid.localeCompare(peerUuid) < 0;
            console.log(`New peer ${peerUuid} detected. Should initiate: ${shouldInitiate}`);
            
            if (shouldInitiate) {
              await createPeerConnection(peerUuid, true);
            }
          }
        }

        // Poll for messages
        const messages = await pollMessages();
        for (const msg of messages) {
          await handleSignalMessage(msg);
        }
      } catch (err) {
        console.error('Polling error:', err);
      }

      setTimeout(pollLoop, 5000); // Poll every 5 seconds instead of 2
    }

    async function pollMessages() {
      try {
        const resp = await fetch(SIGNALING_SERVER + '/latest', {
          headers: { 'X-Master-Key': JSONBIN_API_KEY }
        });
        if (!resp.ok) {
          throw new Error(`Poll failed: ${resp.status}`);
        }
        const data = await resp.json();
        const record = data.record || { messages: {} };
        const myMessages = record.messages?.[myUuid] || [];
        
        if (myMessages.length > 0) {
          record.messages[myUuid] = [];
          await fetch(SIGNALING_SERVER, {
            method: 'PUT',
            headers: {
              'X-Master-Key': JSONBIN_API_KEY,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(record)
          });
        }
        return myMessages;
      } catch (error) {
        return [];
      }
    }

    async function sendToPeer(targetUuid, type, data) {
      let retries = 3;
      while (retries > 0) {
        try {
          const getResp = await fetch(SIGNALING_SERVER + '/latest', {
            headers: { 'X-Master-Key': JSONBIN_API_KEY }
          });
          
          if (getResp.status === 429) {
            retries--;
            if (retries > 0) {
              await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second
              continue;
            }
          }
          
          const result = await getResp.json();
          const record = result.record || { messages: {} };
          
          record.messages = record.messages || {};
          record.messages[targetUuid] = record.messages[targetUuid] || [];
          record.messages[targetUuid].push({ type, data, from: myUuid });
          
          const putResp = await fetch(SIGNALING_SERVER, {
            method: 'PUT',
            headers: {
              'X-Master-Key': JSONBIN_API_KEY,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(record)
          });
          
          if (putResp.status === 429 && retries > 1) {
            retries--;
            await new Promise(resolve => setTimeout(resolve, 1000));
            continue;
          }
          
          break; // Success
        } catch (err) {
          console.error('Send error:', err);
          retries--;
          if (retries > 0) {
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
        }
      }
    }

    // =========================================================================
    // WEBRTC
    // =========================================================================
    async function createPeerConnection(targetUuid, createOffer) {
      if (peers.has(targetUuid)) {
        console.log(`Already have connection to ${targetUuid}`);
        return peers.get(targetUuid);
      }

      console.log(`Creating peer connection to ${targetUuid}, will create offer: ${createOffer}`);
      const pc = new RTCPeerConnection(iceServers);
      peers.set(targetUuid, pc);

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          // Queue ICE candidates instead of sending immediately
          if (!iceCandidateQueue.has(targetUuid)) {
            iceCandidateQueue.set(targetUuid, []);
          }
          iceCandidateQueue.get(targetUuid).push(event.candidate);
          
          // Send batched candidates after a delay
          if (!iceCandidateQueue.get(targetUuid).timer) {
            iceCandidateQueue.get(targetUuid).timer = setTimeout(async () => {
              const candidates = iceCandidateQueue.get(targetUuid);
              if (candidates && candidates.length > 0) {
                console.log(`Sending ${candidates.length} batched ICE candidates to ${targetUuid}`);
                await sendToPeer(targetUuid, 'ice-candidates-batch', candidates);
                iceCandidateQueue.set(targetUuid, []);
              }
            }, 500); // Wait 500ms to batch candidates
          }
        }
      };

      pc.ontrack = (event) => {
        createVideoContainer(targetUuid, event.streams[0], false);
      };

      if (localStream) {
        localStream.getTracks().forEach(track => {
          pc.addTrack(track, localStream);
        });
      }

      if (createOffer) {
        console.log(`Creating and sending offer to ${targetUuid}`);
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await sendToPeer(targetUuid, 'offer', offer);
        console.log(`Offer sent to ${targetUuid}`);
      }

      return pc;
    }

    async function handleSignalMessage(msg) {
      const { type, data, from } = msg;
      
      // Create unique message ID to prevent duplicates
      const msgId = `${from}-${type}-${JSON.stringify(data).substring(0, 50)}`;
      if (processedMessages.has(msgId)) {
        return; // Already processed this message
      }
      processedMessages.add(msgId);
      
      // Clean old processed messages periodically (keep last 100)
      if (processedMessages.size > 100) {
        const messagesToKeep = Array.from(processedMessages).slice(-100);
        processedMessages.clear();
        messagesToKeep.forEach(m => processedMessages.add(m));
      }
      
      // Only log non-ping/pong messages to reduce spam
      if (type !== 'ping' && type !== 'pong' && type !== 'ice-candidate' && type !== 'ice-candidates-batch') {
        console.log(`Received ${type} from ${from}`);
      }

      try {
        switch (type) {
          case 'peer-entered': {
            // A new peer joined, we should connect to them if we're the initiator
            if (!peers.has(from)) {
              const shouldInitiate = myUuid.localeCompare(from) < 0;
              console.log(`New peer ${from} entered. myUuid="${myUuid}" vs from="${from}", shouldInitiate=${shouldInitiate}`);
              if (shouldInitiate) {
                console.log(`Creating connection to new peer: ${from}`);
                await createPeerConnection(from, true);
              } else {
                // The new peer should initiate to us, but let's create a connection to be ready
                console.log(`Creating passive connection for new peer: ${from}`);
                await createPeerConnection(from, false);
              }
            }
            break;
          }
          case 'offer': {
            const pc = await createPeerConnection(from, false);
            await pc.setRemoteDescription(new RTCSessionDescription(data));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            await sendToPeer(from, 'answer', answer);
            break;
          }
          case 'answer': {
            const pc = peers.get(from);
            if (pc) {
              await pc.setRemoteDescription(new RTCSessionDescription(data));
            }
            break;
          }
          case 'ice-candidate': {
            let pc = peers.get(from);
            if (!pc) {
              // We're receiving ICE candidates but don't have a connection yet
              // This can happen if the other peer initiated but we haven't created our side
              console.log(`Creating peer connection for ${from} due to ICE candidate`);
              pc = await createPeerConnection(from, false);
            }
            if (pc) {
              await pc.addIceCandidate(new RTCIceCandidate(data));
            }
            break;
          }
          case 'ice-candidates-batch': {
            const pc = peers.get(from);
            if (pc && Array.isArray(data)) {
              console.log(`Received ${data.length} batched ICE candidates from ${from}`);
              for (const candidate of data) {
                try {
                  await pc.addIceCandidate(new RTCIceCandidate(candidate));
                } catch (err) {
                  console.error('Error adding ICE candidate:', err);
                }
              }
            }
            break;
          }
          case 'ping': {
            // Respond to ping with pong (silently)
            await sendToPeer(from, 'pong', { timestamp: Date.now() });
            break;
          }
          case 'pong': {
            // Mark peer as alive (silently - no log to reduce spam)
            break;
          }
        }
      } catch (err) {
        console.error('Error handling signal:', err);
      }
    }

    function createVideoContainer(uuid, stream, isLocal) {
      let container = document.getElementById(`video-${uuid}`);
      
      if (!container) {
        container = document.createElement('div');
        container.className = 'videoContainer';
        container.id = `video-${uuid}`;

        const video = document.createElement('video');
        video.autoplay = true;
        video.playsInline = true;
        if (isLocal) video.muted = true;

        const label = document.createElement('div');
        label.className = 'peerId';
        const user = users.find(u => u.name === uuid);
        label.textContent = user ? `${user.emoji} ${uuid}` : uuid;
        if (isLocal) label.textContent += ' (You)';

        container.appendChild(video);
        container.appendChild(label);
        document.getElementById('videoGrid').appendChild(container);

        adjustGridLayout();
      }

      const video = container.querySelector('video');
      if (video.srcObject !== stream) {
        video.srcObject = stream;
      }
    }

    function adjustGridLayout() {
      const grid = document.getElementById('videoGrid');
      const count = grid.querySelectorAll('.videoContainer').length;
      
      if (count <= 1) {
        grid.style.gridTemplateColumns = '1fr';
      } else if (count === 2) {
        grid.style.gridTemplateColumns = '1fr 1fr';
      } else if (count <= 4) {
        grid.style.gridTemplateColumns = '1fr 1fr';
      } else {
        grid.style.gridTemplateColumns = '1fr 1fr 1fr';
      }
    }

    // Cleanup on exit
    window.addEventListener('beforeunload', async () => {
      isPolling = false;
      if (myUuid) {
        try {
          const getResp = await fetch(SIGNALING_SERVER + '/latest', {
            headers: { 'X-Master-Key': JSONBIN_API_KEY }
          });
          const data = await getResp.json();
          const record = data.record || {};
          if (record.peers && record.peers[myUuid]) {
            delete record.peers[myUuid];
            delete record.messages[myUuid];
            await fetch(SIGNALING_SERVER, {
              method: 'PUT',
              headers: {
                'X-Master-Key': JSONBIN_API_KEY,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(record)
            });
          }
        } catch (err) {
          console.error('Cleanup error:', err);
        }
      }
      peers.forEach(pc => pc.close());
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
      }
    });
  </script>
</body>
</html>