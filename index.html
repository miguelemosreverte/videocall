<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Video Conference</title>
    <style>
        body { 
            font-family: sans-serif; 
            margin: 0; 
            padding: 20px;
            background: #f0f0f0;
        }
        #videoGrid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            padding: 20px;
        }
        .videoContainer {
            position: relative;
            background: black;
            border-radius: 8px;
            overflow: hidden;
        }
        .videoContainer video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .peerId {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
        }
        #status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div id="status">Initializing...</div>
    <div id="videoGrid"></div>

    <script>
        const API_BASE = 'http://193.124.115.137:3000/api';
        const POLL_INTERVAL = 1000; // Poll every second
        
        let myUuid = null;
        let localStream = null;
        const peers = new Map(); // uuid -> RTCPeerConnection

        // Initialize WebRTC with STUN server
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // API Functions
        async function registerPeer() {
            const response = await fetch(`${API_BASE}/peers`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ uuid: myUuid })
            });
            const data = await response.json();
            return data.peers;
        }

        async function pollMessages() {
            const response = await fetch(`${API_BASE}/peers/${myUuid}/messages`);
            const data = await response.json();
            return data.messages;
        }

        async function sendMessage(targetUuid, type, data) {
            await fetch(`${API_BASE}/peers/${targetUuid}/messages`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    type,
                    data,
                    from: myUuid
                })
            });
        }

        // WebRTC Functions
        function createPeerConnection(targetUuid) {
            if (peers.has(targetUuid)) {
                return peers.get(targetUuid);
            }

            const pc = new RTCPeerConnection(rtcConfig);
            peers.set(targetUuid, pc);

            // Add local tracks
            localStream.getTracks().forEach(track => {
                pc.addTrack(track, localStream);
            });

            // Handle ICE candidates
            pc.onicecandidate = event => {
                if (event.candidate) {
                    sendMessage(targetUuid, 'ice-candidate', event.candidate);
                }
            };

            // Handle incoming tracks
            pc.ontrack = event => {
                displayVideo(targetUuid, event.streams[0]);
            };

            return pc;
        }

        async function handleMessage(message) {
            const { type, data, from } = message;
            const pc = createPeerConnection(from);

            switch (type) {
                case 'offer':
                    await pc.setRemoteDescription(new RTCSessionDescription(data));
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    sendMessage(from, 'answer', answer);
                    break;

                case 'answer':
                    await pc.setRemoteDescription(new RTCSessionDescription(data));
                    break;

                case 'ice-candidate':
                    if (data) {
                        await pc.addIceCandidate(new RTCIceCandidate(data));
                    }
                    break;
            }
        }

        // UI Functions
        function displayVideo(uuid, stream) {
            const existingContainer = document.getElementById(`video-${uuid}`);
            if (existingContainer) {
                const video = existingContainer.querySelector('video');
                if (video.srcObject !== stream) {
                    video.srcObject = stream;
                }
                return;
            }

            const container = document.createElement('div');
            container.id = `video-${uuid}`;
            container.className = 'videoContainer';

            const video = document.createElement('video');
            video.srcObject = stream;
            video.autoplay = true;
            video.playsInline = true;
            if (uuid === myUuid) video.muted = true;

            const label = document.createElement('div');
            label.className = 'peerId';
            label.textContent = uuid === myUuid ? `${uuid} (You)` : uuid;

            container.appendChild(video);
            container.appendChild(label);
            document.getElementById('videoGrid').appendChild(container);
        }

        function updateStatus(text) {
            document.getElementById('status').textContent = text;
        }

        // Main initialization
        async function initialize() {
            try {
                // Generate UUID
                myUuid = 'user-' + Math.random().toString(36).substr(2, 9);
                updateStatus('Accessing camera...');

                // Get user media
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                displayVideo(myUuid, localStream);

                // Start polling loop
                updateStatus('Connected');
                pollLoop();

            } catch (error) {
                console.error('Initialization error:', error);
                updateStatus('Error: ' + error.message);
            }
        }

        async function pollLoop() {
            try {
                // Register and get peer list
                const activePeers = await registerPeer();
                
                // Initiate connections to new peers
                activePeers.forEach(async (peerUuid) => {
                    if (!peers.has(peerUuid)) {
                        const pc = createPeerConnection(peerUuid);
                        const offer = await pc.createOffer();
                        await pc.setLocalDescription(offer);
                        await sendMessage(peerUuid, 'offer', offer);
                    }
                });

                // Check for messages
                const messages = await pollMessages();
                for (const message of messages) {
                    await handleMessage(message);
                }

            } catch (error) {
                console.error('Polling error:', error);
                updateStatus('Connection error - retrying...');
            }

            // Continue polling
            setTimeout(pollLoop, POLL_INTERVAL);
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', async () => {
            if (myUuid) {
                try {
                    await fetch(`${API_BASE}/peers/${myUuid}`, { method: 'DELETE' });
                } catch (error) {
                    console.error('Cleanup error:', error);
                }
            }
            
            peers.forEach(pc => pc.close());
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
        });

        // Start the application
        initialize();
    </script>
</body>
</html>
